{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u8fd9\u91cc\u662fygq\u7684\u535a\u5ba2\uff0c\u4e3b\u8981\u8bb0\u5f55\u6a21\u677f\u548c\u4e00\u4e9b\u9879\u76ee","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"\u8fd9\u91cc\u662fygq\u7684\u535a\u5ba2\uff0c\u4e3b\u8981\u8bb0\u5f55\u6a21\u677f\u548c\u4e00\u4e9b\u9879\u76ee","title":"Welcome to MkDocs"},{"location":"algorithms/dp%E6%A8%A1%E6%9D%BF/dijit/","text":"\u6570\u4f4ddp #include<bits/stdc++.h> using namespace std; typedef long long ll; const int N=20,p=1e9+7; struct F{ ll s0,s1,s2; }f[N][10][7][7]; int power7[N],power9[N]; int mod(ll x,int y){ return (x%y+y)%y; } void init(){ for(int i=0;i<=9;i++){ if(i==7) continue; auto &v=f[1][i][i%7][i%7]; v.s0++; v.s1+=i; v.s2+=i*i; } ll power=10; for(int i=2;i<N;i++,power*=10){ for(int j=0;j<=9;j++){ if(j==7) continue; for(int a=0;a<7;a++){ for(int b=0;b<7;b++){ for(int k=0;k<=9;k++){ if(k==7) continue; auto &v1=f[i][j][a][b],&v2=f[i-1][k][mod(a-j*power%7,7)][mod(b-j,7)]; v1.s0=(v1.s0+v2.s0)%p; v1.s1=(v1.s1+j*(power%p)%p*v2.s0+v2.s1)%p; v1.s2=(v1.s2+j*j*(power%p)%p*(power%p)%p*v2.s0%p + 2*j*(power%p)%p*v2.s1%p + v2.s2)%p; } } } } } power7[0]=power9[0]=1; for(int i=1;i<N;i++){ power7[i]=power7[i-1]*10%7; power9[i]=(ll)power9[i-1]*10%p; } } F get(int i,int j,int a,int b){ int s0=0,s1=0,s2=0; for(int x=0;x<7;x++){ for(int y=0;y<7;y++){ if(x==a || y==b) continue; auto v=f[i][j][x][y]; s0=(s0+v.s0)%p; s1=(s1+v.s1)%p; s2=(s2+v.s2)%p; } } return {s0,s1,s2}; } int dp(ll n){ if(!n) return 0; ll backup_n=n%p; vector<int> nums; while(n) nums.push_back(n%10),n/=10; int res=0; ll last_a=0,last_b=0; for(int i=nums.size()-1;i>=0;i--){ int x=nums[i]; for(int j=0;j<x;j++){ if(j==7) continue; int a=mod(-last_a*power7[i+1],7); int b=mod(-last_b,7); auto v=get(i+1,j,a,b); res=(res + (last_a%p)*(last_a%p)%p*power9[i+1]%p*power9[i+1]%p*v.s0%p + 2*(last_a%p)%p*power9[i+1]%p*v.s1 + v.s2)%p; } if(x==7) break; last_a=last_a*10+x; last_b+=x; if(!i && last_a%7 && last_b%7) res=(res+backup_n*backup_n)%p; } return res; } int main(){ init(); int T; cin>>T; while(T--){ ll l,r; cin>>l>>r; cout<<mod(dp(r)-dp(l-1),p)<<endl; } return 0; }","title":"\u6570\u4f4ddp"},{"location":"algorithms/dp%E6%A8%A1%E6%9D%BF/dijit/#dp","text":"#include<bits/stdc++.h> using namespace std; typedef long long ll; const int N=20,p=1e9+7; struct F{ ll s0,s1,s2; }f[N][10][7][7]; int power7[N],power9[N]; int mod(ll x,int y){ return (x%y+y)%y; } void init(){ for(int i=0;i<=9;i++){ if(i==7) continue; auto &v=f[1][i][i%7][i%7]; v.s0++; v.s1+=i; v.s2+=i*i; } ll power=10; for(int i=2;i<N;i++,power*=10){ for(int j=0;j<=9;j++){ if(j==7) continue; for(int a=0;a<7;a++){ for(int b=0;b<7;b++){ for(int k=0;k<=9;k++){ if(k==7) continue; auto &v1=f[i][j][a][b],&v2=f[i-1][k][mod(a-j*power%7,7)][mod(b-j,7)]; v1.s0=(v1.s0+v2.s0)%p; v1.s1=(v1.s1+j*(power%p)%p*v2.s0+v2.s1)%p; v1.s2=(v1.s2+j*j*(power%p)%p*(power%p)%p*v2.s0%p + 2*j*(power%p)%p*v2.s1%p + v2.s2)%p; } } } } } power7[0]=power9[0]=1; for(int i=1;i<N;i++){ power7[i]=power7[i-1]*10%7; power9[i]=(ll)power9[i-1]*10%p; } } F get(int i,int j,int a,int b){ int s0=0,s1=0,s2=0; for(int x=0;x<7;x++){ for(int y=0;y<7;y++){ if(x==a || y==b) continue; auto v=f[i][j][x][y]; s0=(s0+v.s0)%p; s1=(s1+v.s1)%p; s2=(s2+v.s2)%p; } } return {s0,s1,s2}; } int dp(ll n){ if(!n) return 0; ll backup_n=n%p; vector<int> nums; while(n) nums.push_back(n%10),n/=10; int res=0; ll last_a=0,last_b=0; for(int i=nums.size()-1;i>=0;i--){ int x=nums[i]; for(int j=0;j<x;j++){ if(j==7) continue; int a=mod(-last_a*power7[i+1],7); int b=mod(-last_b,7); auto v=get(i+1,j,a,b); res=(res + (last_a%p)*(last_a%p)%p*power9[i+1]%p*power9[i+1]%p*v.s0%p + 2*(last_a%p)%p*power9[i+1]%p*v.s1 + v.s2)%p; } if(x==7) break; last_a=last_a*10+x; last_b+=x; if(!i && last_a%7 && last_b%7) res=(res+backup_n*backup_n)%p; } return res; } int main(){ init(); int T; cin>>T; while(T--){ ll l,r; cin>>l>>r; cout<<mod(dp(r)-dp(l-1),p)<<endl; } return 0; }","title":"\u6570\u4f4ddp"},{"location":"algorithms/dp%E6%A8%A1%E6%9D%BF/xlyh/","text":"\u659c\u7387\u4f18\u5316dp #include <bits/stdc++.h> #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> #include <ext/pb_ds/hash_policy.hpp> #include <ext/pb_ds/priority_queue.hpp> using namespace std; using namespace __gnu_pbds; using ordered_multiset=tree<int,null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>; typedef long long ll; const int N=3e5+10; int n,s; ll t[N],c[N]; ll f[N]; ll q[N]; void solve(){ cin>>n>>s; for(int i=1;i<=n;i++){ cin>>t[i]>>c[i]; t[i]=t[i]+t[i-1]; c[i]=c[i]+c[i-1]; f[i]=1e18; } int hh=0,tt=0; q[0]=0; for(int i=1;i<=n;i++){ while(hh<tt && (f[q[hh+1]]-f[q[hh]])<=(t[i]+s)*(c[q[hh+1]]-c[q[hh]])) hh++; int j=q[hh]; f[i]=f[j]-(t[i]+s)*c[j]+t[i]*c[i]+s*c[n]; while(hh<tt && (f[q[tt]]-f[q[tt-1]])*(c[i]-c[q[tt]])>=(f[i]-f[q[tt]])*(c[q[tt]]-c[q[tt-1]])); q[++tt]=i; } cout<<f[n]; } int main(){ int T=1; while(T--){ solve(); } return 0; }","title":"\u659c\u7387\u4f18\u5316dp"},{"location":"algorithms/dp%E6%A8%A1%E6%9D%BF/xlyh/#dp","text":"#include <bits/stdc++.h> #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> #include <ext/pb_ds/hash_policy.hpp> #include <ext/pb_ds/priority_queue.hpp> using namespace std; using namespace __gnu_pbds; using ordered_multiset=tree<int,null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>; typedef long long ll; const int N=3e5+10; int n,s; ll t[N],c[N]; ll f[N]; ll q[N]; void solve(){ cin>>n>>s; for(int i=1;i<=n;i++){ cin>>t[i]>>c[i]; t[i]=t[i]+t[i-1]; c[i]=c[i]+c[i-1]; f[i]=1e18; } int hh=0,tt=0; q[0]=0; for(int i=1;i<=n;i++){ while(hh<tt && (f[q[hh+1]]-f[q[hh]])<=(t[i]+s)*(c[q[hh+1]]-c[q[hh]])) hh++; int j=q[hh]; f[i]=f[j]-(t[i]+s)*c[j]+t[i]*c[i]+s*c[n]; while(hh<tt && (f[q[tt]]-f[q[tt-1]])*(c[i]-c[q[tt]])>=(f[i]-f[q[tt]])*(c[q[tt]]-c[q[tt-1]])); q[++tt]=i; } cout<<f[n]; } int main(){ int T=1; while(T--){ solve(); } return 0; }","title":"\u659c\u7387\u4f18\u5316dp"},{"location":"algorithms/pbds/pbds/","text":"pbds\u7528\u6cd5 gp_hash_table<int,int> hash_table; //\u4e0eunordered_map\u7c7b\u4f3c ordered_multiset st; st.order_of_key(val) //\u5c0f\u4e8eval\u6570\u7684\u6570\u91cf st.lower_bound(val) //\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8eval\u7684\u6570\u7684\u6307\u9488 st.upper_bound(val) //\u7b2c\u4e00\u4e2a\u5927\u4e8eval\u7684\u6570\u7684\u6307\u9488 st.insert(val)//\u63d2\u5165\u5143\u7d20 st.erase(st.lower_bound(val))//\u5220\u9664\u5143\u7d20 st.find_by_order(k)//\u627e\u5230\u7b2ck+1\u5c0f\u7684\u5143\u7d20\u7684\u6307\u9488 //less\u5904\u6539\u6210less_equal\u53ef\u4ee5\u63d2\u5165\u76f8\u540c\u5143\u7d20\uff0c\u4f7f\u7528\u540eupper_bound\u548clower_bound\u529f\u80fd\u4e92\u6362","title":"pbds\u7528\u6cd5"},{"location":"algorithms/pbds/pbds/#pbds","text":"gp_hash_table<int,int> hash_table; //\u4e0eunordered_map\u7c7b\u4f3c ordered_multiset st; st.order_of_key(val) //\u5c0f\u4e8eval\u6570\u7684\u6570\u91cf st.lower_bound(val) //\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8eval\u7684\u6570\u7684\u6307\u9488 st.upper_bound(val) //\u7b2c\u4e00\u4e2a\u5927\u4e8eval\u7684\u6570\u7684\u6307\u9488 st.insert(val)//\u63d2\u5165\u5143\u7d20 st.erase(st.lower_bound(val))//\u5220\u9664\u5143\u7d20 st.find_by_order(k)//\u627e\u5230\u7b2ck+1\u5c0f\u7684\u5143\u7d20\u7684\u6307\u9488 //less\u5904\u6539\u6210less_equal\u53ef\u4ee5\u63d2\u5165\u76f8\u540c\u5143\u7d20\uff0c\u4f7f\u7528\u540eupper_bound\u548clower_bound\u529f\u80fd\u4e92\u6362","title":"pbds\u7528\u6cd5"},{"location":"algorithms/%E5%88%9D%E5%A7%8B%E6%A8%A1%E6%9D%BF/starter/","text":"\u521d\u59cb\u5316\u6a21\u677f #include <bits/stdc++.h> #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> #include <ext/pb_ds/hash_policy.hpp> #include <ext/pb_ds/priority_queue.hpp> using namespace std; using namespace __gnu_pbds; template <typename T> using ordered_multiset=tree<T,null_type,less_equal<T>, //less<int>\u8868\u5347\u5e8f\uff0cgreater<int>\u8868\u964d\u5e8f rb_tree_tag,tree_order_statistics_node_update>;//\u5e73\u8861\u6811 typedef long long ll; void solve(){ } int main(){ int T; cin>>T; while(T--){ solve(); } return 0; }","title":"\u521d\u59cb\u5316\u6a21\u677f"},{"location":"algorithms/%E5%88%9D%E5%A7%8B%E6%A8%A1%E6%9D%BF/starter/#_1","text":"#include <bits/stdc++.h> #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> #include <ext/pb_ds/hash_policy.hpp> #include <ext/pb_ds/priority_queue.hpp> using namespace std; using namespace __gnu_pbds; template <typename T> using ordered_multiset=tree<T,null_type,less_equal<T>, //less<int>\u8868\u5347\u5e8f\uff0cgreater<int>\u8868\u964d\u5e8f rb_tree_tag,tree_order_statistics_node_update>;//\u5e73\u8861\u6811 typedef long long ll; void solve(){ } int main(){ int T; cin>>T; while(T--){ solve(); } return 0; }","title":"\u521d\u59cb\u5316\u6a21\u677f"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/bellman-ford/","text":"\u57fa\u7840bellman_ford O(nm) #include<bits/stdc++.h> using namespace std; const int N=510,M=10010; int n,m,k; int dist[N],bakcup[N]; struct Edge{ int a,b,w; }edges[M]; int bellman_ford(){ memset(dist,0x3f,sizeof(dist)); dist[1]=0; for(int i=0;i<k;i++){ memcpy(bakcup,dist,sizeof(dist)); for(int j=0;j<m;j++){ int a=edges[j].a,b=edges[j].b,w=edges[j].w; dist[b]=min(dist[b],bakcup[a]+w); } } if(dist[n]>0x3f3f3f3f/2) return -2147483647; return dist[n]; } int main(){ cin>>n>>m>>k; for(int i=0;i<m;i++){ int a,b,w; cin>>a>>b>>w; edges[i]={a,b,w}; } int t=bellman_ford(); if(t==-2147483647) cout<<\"impossible\"; else cout<<t<<endl; return 0; }","title":"\u57fa\u7840bellman_ford"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/bellman-ford/#bellman_ford","text":"O(nm) #include<bits/stdc++.h> using namespace std; const int N=510,M=10010; int n,m,k; int dist[N],bakcup[N]; struct Edge{ int a,b,w; }edges[M]; int bellman_ford(){ memset(dist,0x3f,sizeof(dist)); dist[1]=0; for(int i=0;i<k;i++){ memcpy(bakcup,dist,sizeof(dist)); for(int j=0;j<m;j++){ int a=edges[j].a,b=edges[j].b,w=edges[j].w; dist[b]=min(dist[b],bakcup[a]+w); } } if(dist[n]>0x3f3f3f3f/2) return -2147483647; return dist[n]; } int main(){ cin>>n>>m>>k; for(int i=0;i<m;i++){ int a,b,w; cin>>a>>b>>w; edges[i]={a,b,w}; } int t=bellman_ford(); if(t==-2147483647) cout<<\"impossible\"; else cout<<t<<endl; return 0; }","title":"\u57fa\u7840bellman_ford"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/betdij/","text":"\u5806\u4f18\u5316dijkstra O(mlogn) #include<bits/stdc++.h> using namespace std; typedef pair<int,int> PII; const int N=150010; int n,m; int h[N],w[N],e[N],ne[N],idx=0; int dist[N]; bool st[N]; void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } int dijkstra(){ memset(dist,0x3f,sizeof(dist)); dist[1]=0; priority_queue<PII,vector<PII>,greater<PII>> heap; heap.push({0,1}); while(heap.size()){ auto t=heap.top(); heap.pop(); int ver=t.second,distance=t.first; if(st[ver]) continue; st[ver]=true; for(int i=h[ver];i!=-1;i=ne[i]){ int j=e[i]; if(dist[j]>distance+w[i]){ dist[j]=distance+w[i]; heap.push({dist[j],j}); } } } if(st[n]!=1) return -1; return dist[n]; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); while(m--){ int a,b,c; cin>>a>>b>>c; add(a,b,c); } int t=dijkstra(); cout<<t<<endl; return 0; }","title":"\u5806\u4f18\u5316dijkstra"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/betdij/#dijkstra","text":"O(mlogn) #include<bits/stdc++.h> using namespace std; typedef pair<int,int> PII; const int N=150010; int n,m; int h[N],w[N],e[N],ne[N],idx=0; int dist[N]; bool st[N]; void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } int dijkstra(){ memset(dist,0x3f,sizeof(dist)); dist[1]=0; priority_queue<PII,vector<PII>,greater<PII>> heap; heap.push({0,1}); while(heap.size()){ auto t=heap.top(); heap.pop(); int ver=t.second,distance=t.first; if(st[ver]) continue; st[ver]=true; for(int i=h[ver];i!=-1;i=ne[i]){ int j=e[i]; if(dist[j]>distance+w[i]){ dist[j]=distance+w[i]; heap.push({dist[j],j}); } } } if(st[n]!=1) return -1; return dist[n]; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); while(m--){ int a,b,c; cin>>a>>b>>c; add(a,b,c); } int t=dijkstra(); cout<<t<<endl; return 0; }","title":"\u5806\u4f18\u5316dijkstra"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/cfys/","text":"\u5dee\u5206\u7ea6\u675f /* \u5dee\u5206\u7ea6\u675f\u4e24\u5927\u5e94\u7528 \u5e94\u7528\u4e00: 1 \u6c42\u4e0d\u7b49\u5f0f\u7ec4\u7684\u53ef\u884c\u89e3 \u2b50\u6e90\u70b9\u9700\u8981\u6ee1\u8db3\u7684\u6761\u4ef6: \u4ece\u6e90\u70b9\u51fa\u53d1,\u4e00\u5b9a\u53ef\u4ee5\u8d70\u5230\u6240\u6709\u7684\u8fb9 \u5426\u5219 \u7528\u5355\u6e90\u6700\u77ed\u8def\u505a\u7684\u8bdd \u6709\u4e00\u6761\u8fb9\u8d70\u4e0d\u5230 \u5219\u8be5\u8fb9\u5bf9\u5e94\u7684\u4e0d\u7b49\u5f0f\u5c31\u65e0\u6cd5\u6ee1\u8db3 \u67d0\u4e00\u4e2a\u70b9x[i]\u8d70\u4e0d\u5230\u65e0\u6240\u8c13(\u67d0\u4e2a\u70b9\u8d70\u4e0d\u5230\u4ee3\u8868\u5b83\u4e0d\u53d7\u9650\u5236,x[i]\u53d6\u4efb\u610f\u6570\u90fd\u53ef\u4ee5) \u8fc7\u7a0b: 1 \u628a\u6bcf\u4e2ax[i] \u2264 x[j] + C[k]\u4e0d\u7b49\u5f0f\u8f6c\u5316\u4e3a\u4e00\u6761\u4ecex[j]\u8d70\u5230x[i]\u957f\u5ea6\u4e3aC[k]\u7684\u8fb9 2 \u7136\u540e\u5728\u8fd9\u4e2a\u56fe\u4e0a\u627e\u4e00\u4e2a\u8d85\u7ea7\u6e90\u70b9,\u4f7f\u5f97\u8be5\u6e90\u70b9\u4e00\u5b9a\u53ef\u4ee5\u904d\u5386\u5230\u6240\u6709\u8fb9 3 \u4ece\u6e90\u70b9\u6c42\u4e00\u904d \u5355\u6e90\u6700\u77ed\u8def 3.1 \u5047\u5982\u5b58\u5728\u8d1f\u73af x[1]\u2192x[2]\u2192x[3]\u2192x[k] \u2191 c1 c2 c3 \u2193 \u2190 \u2190 \u2190 \u2190 \u2190 \u2190 ck x[2]\u2264 x[1]+c[1] ... x[k]\u2264 x[k-1]+c[k-1] x[1]\u2264 x[k]+c[k] \u5bf9\u7b2c\u4e00\u4e2a\u4e0d\u7b49\u5f0f\u7528\u540e\u9762\u7684\u4e0d\u7b49\u5f0f\u4e00\u76f4\u505a\u677e\u5f1b x[2] \u2264 x[1]+c[1] \u2264 x[k]+c[k]+c[1] \u2264 x[k-1]+c[k-1]+c[k]+c[1] ... \u2264 x[2]+c[2]+...+c[k-1]+c[k]+c[1] \u2264 x[2]+(\u5c0f\u4e8e\u96f6\u7684\u03a3c[i]) x[2] < x[2] \u5373\u77db\u76fe \u5f97\u51fa\u7ed3\u8bba:\u4e0d\u7b49\u5f0f\u65e0\u89e3 <=> \u5b58\u5728\u8d1f\u73af 4 \u6c42\u5b8c\u5355\u6e90\u6700\u77ed\u8def\u4e4b\u540e 4.1 \u5b58\u5728\u8d1f\u73af => \u4e0d\u7b49\u5f0f\u65e0\u89e3 4.2 \u6ca1\u6709\u8d1f\u73af => \u6c42\u5b8c\u4e4b\u540e\u4e00\u5b9a\u662f\u6ee1\u8db3\u8fd9\u4e2a\u4e0d\u7b49\u5f0f\u7684 <=> \u5373\u4e00\u4e2a\u53ef\u884c\u89e3 x[i] \u2264 x[j] + C[k] x1 \u2264 x2+1 { x2 \u2264 x3+2 x3 \u2264 x1-5 x1 = 0 x2 = -1 x3 = -2 \u7c7b\u6bd4\u6700\u77ed\u8def i\u2192j \u6c42\u4e4b\u524d d[j] > d[i]+c c \u6c42\u5b8c\u540e d[j] \u2264 d[i]+c \u4e00\u4e2a\u56fe\u91cc\u6bcf\u4e2a\u70b9\u6c42\u5b8c\u6700\u77ed\u8ddd\u79bb\u540e\u6bcf\u4e2a\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\u90fd\u6709\u7b2c\u4e8c\u4e2a\u4e0d\u7b49\u5f0f\u6ee1\u8db3 \u5373 \u4efb\u4f55\u4e00\u4e2a\u6700\u77ed\u8def\u95ee\u9898 \u53ef\u4ee5 \u8f6c\u5316\u4e3a\u4e00\u4e2a\u5dee\u5206\u7ea6\u675f\u95ee\u9898 \u540c\u7406 \u4e00\u4e2a\u5dee\u5206\u7ea6\u675f\u95ee\u9898 \u53ef\u4ee5 \u8f6c\u5316\u4e3a\u4e00\u4e2a\u5355\u6e90\u6700\u77ed\u8def\u95ee\u9898 \u6700\u957f\u8def i\u2192j \u6c42\u4e4b\u524d d[j] < d[i]+c c \u6c42\u5b8c\u540e d[j] \u2265 d[i]+c \u5e94\u7528\u4e8c: 2 \u5982\u4f55\u6c42\u6700\u5927\u503c\u6216\u8005\u6700\u5c0f\u503c(x[i] for i in range(1,n)) \u7ed3\u8bba1:\u5982\u679c\u6c42\u7684\u662f\u6700\u5c0f\u503c,\u5219\u5e94\u8be5\u6c42\u6700\u957f\u8def,\u5982\u679c\u6c42\u7684\u662f\u6700\u5927\u503c,\u5219\u5e94\u8be5\u6c42\u6700\u77ed\u8def \u95ee\u98981:\u5982\u4f55\u8f6c\u5316x[i] \u2264 c \u5176\u4e2dc\u662f\u4e00\u4e2a\u5e38\u6570 \u8fd9\u7c7b\u7684\u4e0d\u7b49\u5f0f \u65b9\u6cd5:\u5efa\u7acb\u4e00\u4e2a\u8d85\u7ea7\u6e90\u70b9,0\u53f7\u70b9x[0],\u7136\u540e\u5efa\u7acb0\u2192i \u957f\u5ea6\u662fc\u7684\u8fb9\u5373\u53ef x[i] \u2264 c <=> x[i] \u2264 x[0] + c = 0 + c \u4ee5\u6c42x[i]\u7684\u6700\u5927\u503c\u4e3a\u4f8b:\u6240\u6709\u4ecex[i]\u51fa\u53d1,\u6784\u6210\u7684\u4e0d\u7b49\u5f0f\u94fe x[i] \u2264 x[j] + c[j] \u2264 x[k] + c[k] + c[j] \u2264 x[0] + c[1]+ c[2]+... + c[j] = 0 + c[1]+ ... + c[j] \u6240\u8ba1\u7b97\u51fa\u7684\u4e0a\u754c, \u6700\u7ec8x[i]\u7684\u6700\u5927\u503c =\u6240\u6709\u4e0a\u754c\u7684\u6700\u5c0f\u503c \u4e3e\u4f8b x[i] \u2264 5 x[i] \u2264 2 x[i] \u2264 3 max(x[i]) = min(5,2,3) = 2 0 \u2192 1 \u2192 3 \u2192 5 \u2192 ... \u2192 i c1 c3 c5 ci-1 x[1] \u2264 x[0] + c[1] x[3] \u2264 x[1] + c[3] x[5] \u2264 x[3] + c[5] ... x[i] \u2264 x[i-1] + c[i-1] \u5219 x[i] \u2264 x[i-1] + c[i] \u2264 x[i-3] + c[i-3] + c[i] ... \u2264 x[0] + c[1] + c[3] + c[i-3] + c[i-1] \u2b50\u53ef\u4ee5\u53d1\u73b0\u03a3c[i]\u5c31\u662f\u4ece0\u2192i\u7684\u4e00\u6761\u8def\u5f84\u7684\u957f\u5ea6 \u90a3\u4e48 \u6c42x[i]\u6700\u5927\u503c <=> \u6c42\u6240\u6709\u4e0a\u754c\u7684\u6700\u5c0f\u503c <=> \u6c42\u6240\u6709\u4ece0\u2192i\u7684\u8def\u5f84\u548c\u7684\u6700\u5c0f\u503c <=> \u6700\u77ed\u8def\u6c42dist[i] \u540c\u7406 \u6c42x[i]\u6700\u5c0f\u503c <=> \u6c42\u6240\u6709\u4e0b\u754c\u7684\u6700\u5927\u503c <=> \u6c42\u6240\u6709\u4ece0\u2192i\u7684\u8def\u5f84\u548c\u7684\u6700\u5927\u503c <=> \u6700\u957f\u8def\u6c42dist[i] */ #include <cstdio> #include <iostream> #include <cstring> using namespace std; const int N = 25; int n, ans, cnt[N], dis[N], R[N], num[N]; int tt, q[N]; bool st[N]; /* \u6700\u957f\u8def 0 <= Si - S(i - 1) */ //\u628a\u8fb9 (u, v, w) \u677e\u5f1b bool inline upd(int u, int v, int w) { if(dis[u] + w > dis[v]) { dis[v] = dis[u] + w; cnt[v] = cnt[u] + 1; if(cnt[v] >= 25) return false; if(!st[v]) q[++tt] = v, st[v] = true; } return true; } // \u8fd4\u56de\u662f\u5426\u5b58\u5728\u53ef\u884c\u89e3 bool spfa() { memset(dis, -0x3f, sizeof dis); memset(st, false, sizeof st); memset(cnt, 0, sizeof cnt); // \u6570\u7ec4\u6a21\u62df\u6808 \u66f4\u5bb9\u6613\u627e\u5230\u73af tt = 0; q[++tt] = 0; dis[0] = 0; while(tt) { int u = q[tt--]; st[u] = false; // \u4e25\u683c\u4fdd\u8bc1 s[24] = ans if(u == 0 && !upd(0, 24, ans)) return false; if(u == 24 && !upd(24, 0, -ans)) return false; // s[i] - s[i - 1] >= 0 if(u < 24 && !upd(u, u + 1, 0)) return false; // s[i] - s[i - 1] <= num[i] if(u > 0 && !upd(u, u - 1, -num[u])) return false; //s[i] - s[i - 8] >= R[i] if(u <= 16 && !upd(u, u + 8, R[u + 8])) return false; // s[i] + s[24] - s[24 - i] >= R[i] if(u >= 17 && !upd(u, u - 16, R[u - 16] - ans)) return false; } return true; } int main() { int T; scanf(\"%d\", &T); while(T--) { memset(num, 0, sizeof num); for (int i = 1; i < N; i++) scanf(\"%d\", R + i); scanf(\"%d\", &n); for (int i = 1, x; i <= n; i++) scanf(\"%d\", &x), x++, num[x]++; bool ok = false; // \u679a\u4e3e s24, s24 \u5c31\u662f \u7b54\u6848 for (ans = 0; ans <= n; ans++) { if(spfa()) { printf(\"%d\\n\", ans); ok = true; break; } } if(!ok) puts(\"No Solution\"); } return 0; }","title":"\u5dee\u5206\u7ea6\u675f"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/cfys/#_1","text":"/* \u5dee\u5206\u7ea6\u675f\u4e24\u5927\u5e94\u7528 \u5e94\u7528\u4e00: 1 \u6c42\u4e0d\u7b49\u5f0f\u7ec4\u7684\u53ef\u884c\u89e3 \u2b50\u6e90\u70b9\u9700\u8981\u6ee1\u8db3\u7684\u6761\u4ef6: \u4ece\u6e90\u70b9\u51fa\u53d1,\u4e00\u5b9a\u53ef\u4ee5\u8d70\u5230\u6240\u6709\u7684\u8fb9 \u5426\u5219 \u7528\u5355\u6e90\u6700\u77ed\u8def\u505a\u7684\u8bdd \u6709\u4e00\u6761\u8fb9\u8d70\u4e0d\u5230 \u5219\u8be5\u8fb9\u5bf9\u5e94\u7684\u4e0d\u7b49\u5f0f\u5c31\u65e0\u6cd5\u6ee1\u8db3 \u67d0\u4e00\u4e2a\u70b9x[i]\u8d70\u4e0d\u5230\u65e0\u6240\u8c13(\u67d0\u4e2a\u70b9\u8d70\u4e0d\u5230\u4ee3\u8868\u5b83\u4e0d\u53d7\u9650\u5236,x[i]\u53d6\u4efb\u610f\u6570\u90fd\u53ef\u4ee5) \u8fc7\u7a0b: 1 \u628a\u6bcf\u4e2ax[i] \u2264 x[j] + C[k]\u4e0d\u7b49\u5f0f\u8f6c\u5316\u4e3a\u4e00\u6761\u4ecex[j]\u8d70\u5230x[i]\u957f\u5ea6\u4e3aC[k]\u7684\u8fb9 2 \u7136\u540e\u5728\u8fd9\u4e2a\u56fe\u4e0a\u627e\u4e00\u4e2a\u8d85\u7ea7\u6e90\u70b9,\u4f7f\u5f97\u8be5\u6e90\u70b9\u4e00\u5b9a\u53ef\u4ee5\u904d\u5386\u5230\u6240\u6709\u8fb9 3 \u4ece\u6e90\u70b9\u6c42\u4e00\u904d \u5355\u6e90\u6700\u77ed\u8def 3.1 \u5047\u5982\u5b58\u5728\u8d1f\u73af x[1]\u2192x[2]\u2192x[3]\u2192x[k] \u2191 c1 c2 c3 \u2193 \u2190 \u2190 \u2190 \u2190 \u2190 \u2190 ck x[2]\u2264 x[1]+c[1] ... x[k]\u2264 x[k-1]+c[k-1] x[1]\u2264 x[k]+c[k] \u5bf9\u7b2c\u4e00\u4e2a\u4e0d\u7b49\u5f0f\u7528\u540e\u9762\u7684\u4e0d\u7b49\u5f0f\u4e00\u76f4\u505a\u677e\u5f1b x[2] \u2264 x[1]+c[1] \u2264 x[k]+c[k]+c[1] \u2264 x[k-1]+c[k-1]+c[k]+c[1] ... \u2264 x[2]+c[2]+...+c[k-1]+c[k]+c[1] \u2264 x[2]+(\u5c0f\u4e8e\u96f6\u7684\u03a3c[i]) x[2] < x[2] \u5373\u77db\u76fe \u5f97\u51fa\u7ed3\u8bba:\u4e0d\u7b49\u5f0f\u65e0\u89e3 <=> \u5b58\u5728\u8d1f\u73af 4 \u6c42\u5b8c\u5355\u6e90\u6700\u77ed\u8def\u4e4b\u540e 4.1 \u5b58\u5728\u8d1f\u73af => \u4e0d\u7b49\u5f0f\u65e0\u89e3 4.2 \u6ca1\u6709\u8d1f\u73af => \u6c42\u5b8c\u4e4b\u540e\u4e00\u5b9a\u662f\u6ee1\u8db3\u8fd9\u4e2a\u4e0d\u7b49\u5f0f\u7684 <=> \u5373\u4e00\u4e2a\u53ef\u884c\u89e3 x[i] \u2264 x[j] + C[k] x1 \u2264 x2+1 { x2 \u2264 x3+2 x3 \u2264 x1-5 x1 = 0 x2 = -1 x3 = -2 \u7c7b\u6bd4\u6700\u77ed\u8def i\u2192j \u6c42\u4e4b\u524d d[j] > d[i]+c c \u6c42\u5b8c\u540e d[j] \u2264 d[i]+c \u4e00\u4e2a\u56fe\u91cc\u6bcf\u4e2a\u70b9\u6c42\u5b8c\u6700\u77ed\u8ddd\u79bb\u540e\u6bcf\u4e2a\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\u90fd\u6709\u7b2c\u4e8c\u4e2a\u4e0d\u7b49\u5f0f\u6ee1\u8db3 \u5373 \u4efb\u4f55\u4e00\u4e2a\u6700\u77ed\u8def\u95ee\u9898 \u53ef\u4ee5 \u8f6c\u5316\u4e3a\u4e00\u4e2a\u5dee\u5206\u7ea6\u675f\u95ee\u9898 \u540c\u7406 \u4e00\u4e2a\u5dee\u5206\u7ea6\u675f\u95ee\u9898 \u53ef\u4ee5 \u8f6c\u5316\u4e3a\u4e00\u4e2a\u5355\u6e90\u6700\u77ed\u8def\u95ee\u9898 \u6700\u957f\u8def i\u2192j \u6c42\u4e4b\u524d d[j] < d[i]+c c \u6c42\u5b8c\u540e d[j] \u2265 d[i]+c \u5e94\u7528\u4e8c: 2 \u5982\u4f55\u6c42\u6700\u5927\u503c\u6216\u8005\u6700\u5c0f\u503c(x[i] for i in range(1,n)) \u7ed3\u8bba1:\u5982\u679c\u6c42\u7684\u662f\u6700\u5c0f\u503c,\u5219\u5e94\u8be5\u6c42\u6700\u957f\u8def,\u5982\u679c\u6c42\u7684\u662f\u6700\u5927\u503c,\u5219\u5e94\u8be5\u6c42\u6700\u77ed\u8def \u95ee\u98981:\u5982\u4f55\u8f6c\u5316x[i] \u2264 c \u5176\u4e2dc\u662f\u4e00\u4e2a\u5e38\u6570 \u8fd9\u7c7b\u7684\u4e0d\u7b49\u5f0f \u65b9\u6cd5:\u5efa\u7acb\u4e00\u4e2a\u8d85\u7ea7\u6e90\u70b9,0\u53f7\u70b9x[0],\u7136\u540e\u5efa\u7acb0\u2192i \u957f\u5ea6\u662fc\u7684\u8fb9\u5373\u53ef x[i] \u2264 c <=> x[i] \u2264 x[0] + c = 0 + c \u4ee5\u6c42x[i]\u7684\u6700\u5927\u503c\u4e3a\u4f8b:\u6240\u6709\u4ecex[i]\u51fa\u53d1,\u6784\u6210\u7684\u4e0d\u7b49\u5f0f\u94fe x[i] \u2264 x[j] + c[j] \u2264 x[k] + c[k] + c[j] \u2264 x[0] + c[1]+ c[2]+... + c[j] = 0 + c[1]+ ... + c[j] \u6240\u8ba1\u7b97\u51fa\u7684\u4e0a\u754c, \u6700\u7ec8x[i]\u7684\u6700\u5927\u503c =\u6240\u6709\u4e0a\u754c\u7684\u6700\u5c0f\u503c \u4e3e\u4f8b x[i] \u2264 5 x[i] \u2264 2 x[i] \u2264 3 max(x[i]) = min(5,2,3) = 2 0 \u2192 1 \u2192 3 \u2192 5 \u2192 ... \u2192 i c1 c3 c5 ci-1 x[1] \u2264 x[0] + c[1] x[3] \u2264 x[1] + c[3] x[5] \u2264 x[3] + c[5] ... x[i] \u2264 x[i-1] + c[i-1] \u5219 x[i] \u2264 x[i-1] + c[i] \u2264 x[i-3] + c[i-3] + c[i] ... \u2264 x[0] + c[1] + c[3] + c[i-3] + c[i-1] \u2b50\u53ef\u4ee5\u53d1\u73b0\u03a3c[i]\u5c31\u662f\u4ece0\u2192i\u7684\u4e00\u6761\u8def\u5f84\u7684\u957f\u5ea6 \u90a3\u4e48 \u6c42x[i]\u6700\u5927\u503c <=> \u6c42\u6240\u6709\u4e0a\u754c\u7684\u6700\u5c0f\u503c <=> \u6c42\u6240\u6709\u4ece0\u2192i\u7684\u8def\u5f84\u548c\u7684\u6700\u5c0f\u503c <=> \u6700\u77ed\u8def\u6c42dist[i] \u540c\u7406 \u6c42x[i]\u6700\u5c0f\u503c <=> \u6c42\u6240\u6709\u4e0b\u754c\u7684\u6700\u5927\u503c <=> \u6c42\u6240\u6709\u4ece0\u2192i\u7684\u8def\u5f84\u548c\u7684\u6700\u5927\u503c <=> \u6700\u957f\u8def\u6c42dist[i] */ #include <cstdio> #include <iostream> #include <cstring> using namespace std; const int N = 25; int n, ans, cnt[N], dis[N], R[N], num[N]; int tt, q[N]; bool st[N]; /* \u6700\u957f\u8def 0 <= Si - S(i - 1) */ //\u628a\u8fb9 (u, v, w) \u677e\u5f1b bool inline upd(int u, int v, int w) { if(dis[u] + w > dis[v]) { dis[v] = dis[u] + w; cnt[v] = cnt[u] + 1; if(cnt[v] >= 25) return false; if(!st[v]) q[++tt] = v, st[v] = true; } return true; } // \u8fd4\u56de\u662f\u5426\u5b58\u5728\u53ef\u884c\u89e3 bool spfa() { memset(dis, -0x3f, sizeof dis); memset(st, false, sizeof st); memset(cnt, 0, sizeof cnt); // \u6570\u7ec4\u6a21\u62df\u6808 \u66f4\u5bb9\u6613\u627e\u5230\u73af tt = 0; q[++tt] = 0; dis[0] = 0; while(tt) { int u = q[tt--]; st[u] = false; // \u4e25\u683c\u4fdd\u8bc1 s[24] = ans if(u == 0 && !upd(0, 24, ans)) return false; if(u == 24 && !upd(24, 0, -ans)) return false; // s[i] - s[i - 1] >= 0 if(u < 24 && !upd(u, u + 1, 0)) return false; // s[i] - s[i - 1] <= num[i] if(u > 0 && !upd(u, u - 1, -num[u])) return false; //s[i] - s[i - 8] >= R[i] if(u <= 16 && !upd(u, u + 8, R[u + 8])) return false; // s[i] + s[24] - s[24 - i] >= R[i] if(u >= 17 && !upd(u, u - 16, R[u - 16] - ans)) return false; } return true; } int main() { int T; scanf(\"%d\", &T); while(T--) { memset(num, 0, sizeof num); for (int i = 1; i < N; i++) scanf(\"%d\", R + i); scanf(\"%d\", &n); for (int i = 1, x; i <= n; i++) scanf(\"%d\", &x), x++, num[x]++; bool ok = false; // \u679a\u4e3e s24, s24 \u5c31\u662f \u7b54\u6848 for (ans = 0; ans <= n; ans++) { if(spfa()) { printf(\"%d\\n\", ans); ok = true; break; } } if(!ok) puts(\"No Solution\"); } return 0; }","title":"\u5dee\u5206\u7ea6\u675f"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/cixiao/","text":"\u6b21\u5c0f\u751f\u6210\u6811 #include<bits/stdc++.h> using namespace std; const int N=24; int op[8][7]={ {0,2,6,11,15,20,22}, {1,3,8,12,17,21,23}, {10,9,8,7,6,5,4}, {19,18,17,16,15,14,13}, {23,21,17,12,8,3,1}, {22,20,15,11,6,2,0}, {13,14,15,16,17,18,19}, {4,5,6,7,8,9,10} }; int opposite[8]={5,4,7,6,1,0,3,2}; int center[8]={6,7,8,11,12,15,16,17}; int q[N]; int path[100]; int f(){ int sum[4]={0}; for(int i=0;i<8;i++) sum[q[center[i]]]++; int s=0; for(int i=1;i<=3;i++){ s=max(sum[i],s); } return 8-s; } void operate(int x){ int t=q[op[x][0]]; for(int i=0;i<6;i++) q[op[x][i]]=q[op[x][i+1]]; q[op[x][6]]=t; } bool dfs(int depth,int max_depth,int last){ if(depth+f()>max_depth) return false; if(f()==0) return true; for(int i=0;i<8;i++){ if(opposite[i]!=last){ operate(i); path[depth]=i; if(dfs(depth+1,max_depth,i)) return true; operate(opposite[i]); } } return false; } int main(){ while(cin>>q[0],q[0]){ for(int i=1;i<N;i++) cin>>q[i]; int depth=0; while(!dfs(0,depth,-1)) depth++; if(!depth) cout<<\"No moves needed\"; else{ for(int i=0;i<depth;i++){ cout<<char(path[i]+'A'); } } cout<<endl<<q[6]<<endl; } }","title":"\u6b21\u5c0f\u751f\u6210\u6811"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/cixiao/#_1","text":"#include<bits/stdc++.h> using namespace std; const int N=24; int op[8][7]={ {0,2,6,11,15,20,22}, {1,3,8,12,17,21,23}, {10,9,8,7,6,5,4}, {19,18,17,16,15,14,13}, {23,21,17,12,8,3,1}, {22,20,15,11,6,2,0}, {13,14,15,16,17,18,19}, {4,5,6,7,8,9,10} }; int opposite[8]={5,4,7,6,1,0,3,2}; int center[8]={6,7,8,11,12,15,16,17}; int q[N]; int path[100]; int f(){ int sum[4]={0}; for(int i=0;i<8;i++) sum[q[center[i]]]++; int s=0; for(int i=1;i<=3;i++){ s=max(sum[i],s); } return 8-s; } void operate(int x){ int t=q[op[x][0]]; for(int i=0;i<6;i++) q[op[x][i]]=q[op[x][i+1]]; q[op[x][6]]=t; } bool dfs(int depth,int max_depth,int last){ if(depth+f()>max_depth) return false; if(f()==0) return true; for(int i=0;i<8;i++){ if(opposite[i]!=last){ operate(i); path[depth]=i; if(dfs(depth+1,max_depth,i)) return true; operate(opposite[i]); } } return false; } int main(){ while(cin>>q[0],q[0]){ for(int i=1;i<N;i++) cin>>q[i]; int depth=0; while(!dfs(0,depth,-1)) depth++; if(!depth) cout<<\"No moves needed\"; else{ for(int i=0;i<depth;i++){ cout<<char(path[i]+'A'); } } cout<<endl<<q[6]<<endl; } }","title":"\u6b21\u5c0f\u751f\u6210\u6811"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/color/","text":"\u67d3\u8272\u6cd5\u5224\u65ad\u4e8c\u5206\u56fe O(nm) #include<bits/stdc++.h> using namespace std; const int N=1e6+10,M=2e6+10; int n,m; int h[N],e[M],ne[M],idx; int color[N]; void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++; } bool dfs(int u,int c){ color[u]=c; for(int i=h[u];i!=-1;i=ne[i]){ int j=e[i]; if(!color[j]){ if(!dfs(j,3-c)) return false; } else if(color[j]==c){ return false; break; } } return true; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); while(m--){ int a,b; cin>>a>>b; add(a,b); add(b,a); } bool flag=true; for(int i=1;i<=n;i++){ if(!color[i]){ if(!dfs(i,1)){ flag=false; break; } } } if(flag) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl; return 0; }","title":"\u67d3\u8272\u6cd5\u5224\u65ad\u4e8c\u5206\u56fe"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/color/#_1","text":"O(nm) #include<bits/stdc++.h> using namespace std; const int N=1e6+10,M=2e6+10; int n,m; int h[N],e[M],ne[M],idx; int color[N]; void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++; } bool dfs(int u,int c){ color[u]=c; for(int i=h[u];i!=-1;i=ne[i]){ int j=e[i]; if(!color[j]){ if(!dfs(j,3-c)) return false; } else if(color[j]==c){ return false; break; } } return true; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); while(m--){ int a,b; cin>>a>>b; add(a,b); add(b,a); } bool flag=true; for(int i=1;i<=n;i++){ if(!color[i]){ if(!dfs(i,1)){ flag=false; break; } } } if(flag) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl; return 0; }","title":"\u67d3\u8272\u6cd5\u5224\u65ad\u4e8c\u5206\u56fe"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/dijkstra/","text":"\u57fa\u7840dijkstra O(n^2) #include<bits/stdc++.h> using namespace std; const int N=510; int n,m; int g[N][N]; int dist[N]; bool st[N]; int dijkstra(){ memset(dist,0x3f,sizeof(dist)); dist[1]=0; for(int i=0;i<n;i++){ int t=-1; for(int j=1;j<=n;j++){ if(!st[j] && (t==-1 || dist[t]>dist[j])) t=j; } st[t]=true; for(int j=1;j<=n;j++){ dist[j]=min(dist[j],dist[t]+g[t][j]); } } if(dist[n]==0x3f3f3f3f) return -1; return dist[n]; } int main(){ cin>>n>>m; memset(g,0x3f,sizeof(g)); while(m--){ int a,b,c; cin>>a>>b>>c; g[a][b]=min(g[a][b],c); } int t=dijkstra(); cout<<t<<endl; return 0; }","title":"\u57fa\u7840dijkstra"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/dijkstra/#dijkstra","text":"O(n^2) #include<bits/stdc++.h> using namespace std; const int N=510; int n,m; int g[N][N]; int dist[N]; bool st[N]; int dijkstra(){ memset(dist,0x3f,sizeof(dist)); dist[1]=0; for(int i=0;i<n;i++){ int t=-1; for(int j=1;j<=n;j++){ if(!st[j] && (t==-1 || dist[t]>dist[j])) t=j; } st[t]=true; for(int j=1;j<=n;j++){ dist[j]=min(dist[j],dist[t]+g[t][j]); } } if(dist[n]==0x3f3f3f3f) return -1; return dist[n]; } int main(){ cin>>n>>m; memset(g,0x3f,sizeof(g)); while(m--){ int a,b,c; cin>>a>>b>>c; g[a][b]=min(g[a][b],c); } int t=dijkstra(); cout<<t<<endl; return 0; }","title":"\u57fa\u7840dijkstra"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/floyd/","text":"\u57fa\u7840floyd O(n^3) #include<bits/stdc++.h> using namespace std; const int N=210,INF=1e9; int n,m,Q; int d[N][N]; void floyd(){ for(int k=1;k<=n;k++){ for(int i=1;i<=n;i++){ for(int j=1;j<=n;j++){ d[i][j]=min(d[i][j],d[i][k]+d[k][j]); } } } } int main(){ cin>>n>>m>>Q; for(int i=1;i<=n;i++){ for(int j=1;j<=n;j++){ if(i==j) d[i][j]=0; else d[i][j]=INF; } } while(m--){ int a,b,w; cin>>a>>b>>w; d[a][b]=min(d[a][b],w); } floyd(); while(Q--){ int a,b; cin>>a>>b; if(d[a][b]>INF/2) cout<<\"impossible\"<<endl; else cout<<d[a][b]<<endl; } }","title":"\u57fa\u7840floyd"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/floyd/#floyd","text":"O(n^3) #include<bits/stdc++.h> using namespace std; const int N=210,INF=1e9; int n,m,Q; int d[N][N]; void floyd(){ for(int k=1;k<=n;k++){ for(int i=1;i<=n;i++){ for(int j=1;j<=n;j++){ d[i][j]=min(d[i][j],d[i][k]+d[k][j]); } } } } int main(){ cin>>n>>m>>Q; for(int i=1;i<=n;i++){ for(int j=1;j<=n;j++){ if(i==j) d[i][j]=0; else d[i][j]=INF; } } while(m--){ int a,b,w; cin>>a>>b>>w; d[a][b]=min(d[a][b],w); } floyd(); while(Q--){ int a,b; cin>>a>>b; if(d[a][b]>INF/2) cout<<\"impossible\"<<endl; else cout<<d[a][b]<<endl; } }","title":"\u57fa\u7840floyd"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/kruska/","text":"\u57fa\u7840kruska O(mlogm) #include<bits/stdc++.h> using namespace std; const int N=1e6+10; int n,m; int p[N]; struct Edge{ int a,b,w; bool operator<(const Edge &W)const{ return w<W.w; } }edges[N]; int find(int x){ if(p[x]!=x) p[x]=find(p[x]); return p[x]; } int main(){ cin>>n>>m; for(int i=0;i<m;i++){ int a,b,w; cin>>a>>b>>w; edges[i]={a,b,w}; } sort(edges,edges+m); for(int i=1;i<=n;i++) p[i]=i; int res=0,cnt=0; for(int i=0;i<m;i++){ int a=edges[i].a,b=edges[i].b,w=edges[i].w; a=find(a),b=find(b); if(a!=b){ p[a]=b; res+=w; cnt++; } } if(cnt<n-1){ cout<<\"impossible\"<<endl; } else cout<<res; return 0; }","title":"\u57fa\u7840kruska"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/kruska/#kruska","text":"O(mlogm) #include<bits/stdc++.h> using namespace std; const int N=1e6+10; int n,m; int p[N]; struct Edge{ int a,b,w; bool operator<(const Edge &W)const{ return w<W.w; } }edges[N]; int find(int x){ if(p[x]!=x) p[x]=find(p[x]); return p[x]; } int main(){ cin>>n>>m; for(int i=0;i<m;i++){ int a,b,w; cin>>a>>b>>w; edges[i]={a,b,w}; } sort(edges,edges+m); for(int i=1;i<=n;i++) p[i]=i; int res=0,cnt=0; for(int i=0;i<m;i++){ int a=edges[i].a,b=edges[i].b,w=edges[i].w; a=find(a),b=find(b); if(a!=b){ p[a]=b; res+=w; cnt++; } } if(cnt<n-1){ cout<<\"impossible\"<<endl; } else cout<<res; return 0; }","title":"\u57fa\u7840kruska"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/kruskals/","text":"lca\u6c42\u6700\u8fd1\u516c\u5171\u7956\u5148\u4f18\u5316\u6b21\u5c0f\u751f\u6210\u6811 #include<bits/stdc++.h> using namespace std; const int N=100010,M=300010,INF=0x3f3f3f3f; typedef long long LL; int n,m; struct Edge{ int a,b,w; bool used; bool operator<(const Edge &t) const{ return w<t.w; } }edge[M]; int p[N]; int h[N],e[M],w[M],ne[M],idx; int depth[N],fa[N][17],d1[N][17],d2[N][17]; int q[N]; void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } int find(int x){ if(p[x]!=x) p[x]=find(p[x]); return p[x]; } LL kruskal(){ for(int i=1;i<=n;i++) p[i]=i; sort(edge,edge+m); LL res=0; for(int i=0;i<m;i++){ int a=find(edge[i].a),b=find(edge[i].b),w=edge[i].w; if(a!=b){ p[a]=b; res+=w; edge[i].used=true; } } return res; } void build(){ memset(h,-1,sizeof(h)); for(int i=0;i<m;i++){ if(edge[i].used){ int a=edge[i].a,b=edge[i].b,w=edge[i].w; add(a,b,w),add(b,a,w); } } } void bfs(){ memset(depth,0x3f,sizeof(depth)); depth[0]=0,depth[1]=1; int hh=0,tt=0; q[0]=1; while(hh<=tt){ int t=q[hh++]; for(int i=h[t];~i;i=ne[i]){ int j=e[i]; if(depth[j]>depth[t]+1){ depth[j]=depth[t]+1; q[++tt]=j; fa[j][0]=t; d1[j][0]=w[i],d2[j][0]=-INF; for(int k=1;k<=16;k++){ int anc=fa[j][k-1]; fa[j][k]=fa[anc][k-1]; int distance[4]={d1[j][k-1],d2[j][k-1],d1[anc][k-1],d2[anc][k-1]}; d1[j][k]=d2[j][k]=-INF; for(int u=0;u<4;u++){ int d=distance[u]; if(d>d1[j][k]) d2[j][k]=d1[j][k],d1[j][k]=d; else if(d!=d1[j][k] && d>d2[j][k]) d2[j][k]=d; } } } } } } int lca(int a,int b,int w){ static int distance[N*2]; int cnt=0; if(depth[a]<depth[b]) swap(a,b); for(int k=16;k>=0;k--){ if(depth[fa[a][k]]>=depth[b]){ distance[cnt++]=d1[a][k]; distance[cnt++]=d2[a][k]; a=fa[a][k]; } } if(a!=b){ for(int k=16;k>=0;k--){ if(fa[a][k]!=fa[b][k]){ distance[cnt++]=d1[a][k]; distance[cnt++]=d2[a][k]; distance[cnt++]=d1[b][k]; distance[cnt++]=d2[b][k]; a=fa[a][k],b=fa[b][k]; } } distance[cnt++]=d1[a][0]; distance[cnt++]=d1[b][0]; } int dist1=-INF,dist2=-INF; for(int i=0;i<cnt;i++){ int d=distance[i]; if(d>dist1) dist2=dist1,dist1=d; else if(d!=dist1 && d>dist2) dist2=d; } if(w>dist1) return w-dist1; if(w>dist2) return w-dist2; return INF; } int main(){ cin>>n>>m; for(int i=0;i<m;i++){ int a,b,c; cin>>a>>b>>c; edge[i]={a,b,c}; } LL sum=kruskal(); build(); bfs(); LL res=1e18; for(int i=0;i<m;i++){ if(!edge[i].used){ int a=edge[i].a,b=edge[i].b,w=edge[i].w; res=min(res,sum+lca(a,b,w)); } } cout<<res<<endl; return 0; }","title":"lca\u6c42\u6700\u8fd1\u516c\u5171\u7956\u5148\u4f18\u5316\u6b21\u5c0f\u751f\u6210\u6811"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/kruskals/#lca","text":"#include<bits/stdc++.h> using namespace std; const int N=100010,M=300010,INF=0x3f3f3f3f; typedef long long LL; int n,m; struct Edge{ int a,b,w; bool used; bool operator<(const Edge &t) const{ return w<t.w; } }edge[M]; int p[N]; int h[N],e[M],w[M],ne[M],idx; int depth[N],fa[N][17],d1[N][17],d2[N][17]; int q[N]; void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } int find(int x){ if(p[x]!=x) p[x]=find(p[x]); return p[x]; } LL kruskal(){ for(int i=1;i<=n;i++) p[i]=i; sort(edge,edge+m); LL res=0; for(int i=0;i<m;i++){ int a=find(edge[i].a),b=find(edge[i].b),w=edge[i].w; if(a!=b){ p[a]=b; res+=w; edge[i].used=true; } } return res; } void build(){ memset(h,-1,sizeof(h)); for(int i=0;i<m;i++){ if(edge[i].used){ int a=edge[i].a,b=edge[i].b,w=edge[i].w; add(a,b,w),add(b,a,w); } } } void bfs(){ memset(depth,0x3f,sizeof(depth)); depth[0]=0,depth[1]=1; int hh=0,tt=0; q[0]=1; while(hh<=tt){ int t=q[hh++]; for(int i=h[t];~i;i=ne[i]){ int j=e[i]; if(depth[j]>depth[t]+1){ depth[j]=depth[t]+1; q[++tt]=j; fa[j][0]=t; d1[j][0]=w[i],d2[j][0]=-INF; for(int k=1;k<=16;k++){ int anc=fa[j][k-1]; fa[j][k]=fa[anc][k-1]; int distance[4]={d1[j][k-1],d2[j][k-1],d1[anc][k-1],d2[anc][k-1]}; d1[j][k]=d2[j][k]=-INF; for(int u=0;u<4;u++){ int d=distance[u]; if(d>d1[j][k]) d2[j][k]=d1[j][k],d1[j][k]=d; else if(d!=d1[j][k] && d>d2[j][k]) d2[j][k]=d; } } } } } } int lca(int a,int b,int w){ static int distance[N*2]; int cnt=0; if(depth[a]<depth[b]) swap(a,b); for(int k=16;k>=0;k--){ if(depth[fa[a][k]]>=depth[b]){ distance[cnt++]=d1[a][k]; distance[cnt++]=d2[a][k]; a=fa[a][k]; } } if(a!=b){ for(int k=16;k>=0;k--){ if(fa[a][k]!=fa[b][k]){ distance[cnt++]=d1[a][k]; distance[cnt++]=d2[a][k]; distance[cnt++]=d1[b][k]; distance[cnt++]=d2[b][k]; a=fa[a][k],b=fa[b][k]; } } distance[cnt++]=d1[a][0]; distance[cnt++]=d1[b][0]; } int dist1=-INF,dist2=-INF; for(int i=0;i<cnt;i++){ int d=distance[i]; if(d>dist1) dist2=dist1,dist1=d; else if(d!=dist1 && d>dist2) dist2=d; } if(w>dist1) return w-dist1; if(w>dist2) return w-dist2; return INF; } int main(){ cin>>n>>m; for(int i=0;i<m;i++){ int a,b,c; cin>>a>>b>>c; edge[i]={a,b,c}; } LL sum=kruskal(); build(); bfs(); LL res=1e18; for(int i=0;i<m;i++){ if(!edge[i].used){ int a=edge[i].a,b=edge[i].b,w=edge[i].w; res=min(res,sum+lca(a,b,w)); } } cout<<res<<endl; return 0; }","title":"lca\u6c42\u6700\u8fd1\u516c\u5171\u7956\u5148\u4f18\u5316\u6b21\u5c0f\u751f\u6210\u6811"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/lca/","text":"lca\u6c42\u6700\u8fd1\u516c\u5171\u7956\u5148 #include<bits/stdc++.h> using namespace std; const int N=40010,M=N*2; int n,m; int h[N],e[M],ne[M],idx; int depth[N],fa[N][16]; int q[N]; void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++; } void bfs(int root){ memset(depth,0x3f,sizeof(depth)); depth[0]=0,depth[root]=1; int hh=0,tt=0; q[0]=root; while(hh<=tt){ int t=q[hh++]; for(int i=h[t];~i;i=ne[i]){ int j=e[i]; if(depth[j]>depth[t]+1){ depth[j]=depth[t]+1; q[++tt]=j; fa[j][0]=t; for(int k=1;k<=15;k++){ fa[j][k]=fa[fa[j][k-1]][k-1]; } } } } } int lca(int a,int b){ if(depth[a]<depth[b]) swap(a,b); for(int k=15;k>=0;k--){ if(depth[fa[a][k]]>=depth[b]){ a=fa[a][k]; } } if(a==b) return a; for(int k=15;k>=0;k--){ if(fa[a][k]!=fa[b][k]){ a=fa[a][k]; b=fa[b][k]; } } return fa[a][0]; } int main(){ cin>>n; int root=0; memset(h,-1,sizeof(h)); for(int i=0;i<n;i++){ int a,b; cin>>a>>b; if(b==-1) root=a; else add(a,b),add(b,a); } bfs(root); cin>>m; while(m--){ int a,b; cin>>a>>b; int p=lca(a,b); if(p==a) cout<<1<<endl; else if(p==b) cout<<2<<endl; else cout<<0<<endl; } return 0; }","title":"lca\u6c42\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/lca/#lca","text":"#include<bits/stdc++.h> using namespace std; const int N=40010,M=N*2; int n,m; int h[N],e[M],ne[M],idx; int depth[N],fa[N][16]; int q[N]; void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++; } void bfs(int root){ memset(depth,0x3f,sizeof(depth)); depth[0]=0,depth[root]=1; int hh=0,tt=0; q[0]=root; while(hh<=tt){ int t=q[hh++]; for(int i=h[t];~i;i=ne[i]){ int j=e[i]; if(depth[j]>depth[t]+1){ depth[j]=depth[t]+1; q[++tt]=j; fa[j][0]=t; for(int k=1;k<=15;k++){ fa[j][k]=fa[fa[j][k-1]][k-1]; } } } } } int lca(int a,int b){ if(depth[a]<depth[b]) swap(a,b); for(int k=15;k>=0;k--){ if(depth[fa[a][k]]>=depth[b]){ a=fa[a][k]; } } if(a==b) return a; for(int k=15;k>=0;k--){ if(fa[a][k]!=fa[b][k]){ a=fa[a][k]; b=fa[b][k]; } } return fa[a][0]; } int main(){ cin>>n; int root=0; memset(h,-1,sizeof(h)); for(int i=0;i<n;i++){ int a,b; cin>>a>>b; if(b==-1) root=a; else add(a,b),add(b,a); } bfs(root); cin>>m; while(m--){ int a,b; cin>>a>>b; int p=lca(a,b); if(p==a) cout<<1<<endl; else if(p==b) cout<<2<<endl; else cout<<0<<endl; } return 0; }","title":"lca\u6c42\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/prim/","text":"prim\u7b97\u6cd5\u5224\u65ad\u6700\u77ed\u8def O(n^2) #include<bits/stdc++.h> using namespace std; const int N=510,INF=0x3f3f3f3f; int n,m; int g[N][N]; int dist[N]; bool st[N]; int prim(){ memset(dist,0x3f,sizeof(dist)); int res=0; for(int i=0;i<n;i++){ int t=-1; for(int j=1;j<=n;j++){ if(!st[j] && (t==-1 || dist[t]>dist[j])) t=j; } if(i && dist[t]==INF) return INF; if(i) res+=dist[t]; for(int j=1;j<=n;j++) dist[j]=min(dist[j],g[t][j]); st[t]=true; } return res; } int main(){ cin>>n>>m; memset(g,0x3f,sizeof(g)); while(m--){ int a,b,c; cin>>a>>b>>c; g[a][b]=g[b][a]=min(g[a][b],c); } int t=prim(); if(t==INF) cout<<\"impossible\"<<endl; else cout<<t<<endl; return 0; }","title":"prim\u7b97\u6cd5\u5224\u65ad\u6700\u77ed\u8def"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/prim/#prim","text":"O(n^2) #include<bits/stdc++.h> using namespace std; const int N=510,INF=0x3f3f3f3f; int n,m; int g[N][N]; int dist[N]; bool st[N]; int prim(){ memset(dist,0x3f,sizeof(dist)); int res=0; for(int i=0;i<n;i++){ int t=-1; for(int j=1;j<=n;j++){ if(!st[j] && (t==-1 || dist[t]>dist[j])) t=j; } if(i && dist[t]==INF) return INF; if(i) res+=dist[t]; for(int j=1;j<=n;j++) dist[j]=min(dist[j],g[t][j]); st[t]=true; } return res; } int main(){ cin>>n>>m; memset(g,0x3f,sizeof(g)); while(m--){ int a,b,c; cin>>a>>b>>c; g[a][b]=g[b][a]=min(g[a][b],c); } int t=prim(); if(t==INF) cout<<\"impossible\"<<endl; else cout<<t<<endl; return 0; }","title":"prim\u7b97\u6cd5\u5224\u65ad\u6700\u77ed\u8def"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/spfa/","text":"\u57fa\u7840spfa O(m)->O(nm) #include<bits/stdc++.h> using namespace std; typedef pair<int,int> PII; const int N=110010; int n,m; int h[N],w[N],e[N],ne[N],idx=0; int dist[N]; bool st[N]; void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } int spfa(){ memset(dist,0x3f,sizeof(dist)); dist[1]=0; queue<int> q; q.push(1); st[1]=true; while(q.size()){ int t=q.front(); q.pop(); st[t]=false; for(int i=h[t];i!=-1;i=ne[i]){ int j=e[i]; if(dist[j]>dist[t]+w[i]){ dist[j]=dist[t]+w[i]; if(!st[j]){ q.push(j); st[j]=true; } } } } if(dist[n]==0x3f3f3f3f) return -2147483647; return dist[n]; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); while(m--){ int a,b,c; cin>>a>>b>>c; add(a,b,c); } int t=spfa(); if(t==-2147483647) cout<<\"impossible\"<<endl; else cout<<t<<endl; return 0; }","title":"\u57fa\u7840spfa"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/spfa/#spfa","text":"O(m)->O(nm) #include<bits/stdc++.h> using namespace std; typedef pair<int,int> PII; const int N=110010; int n,m; int h[N],w[N],e[N],ne[N],idx=0; int dist[N]; bool st[N]; void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } int spfa(){ memset(dist,0x3f,sizeof(dist)); dist[1]=0; queue<int> q; q.push(1); st[1]=true; while(q.size()){ int t=q.front(); q.pop(); st[t]=false; for(int i=h[t];i!=-1;i=ne[i]){ int j=e[i]; if(dist[j]>dist[t]+w[i]){ dist[j]=dist[t]+w[i]; if(!st[j]){ q.push(j); st[j]=true; } } } } if(dist[n]==0x3f3f3f3f) return -2147483647; return dist[n]; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); while(m--){ int a,b,c; cin>>a>>b>>c; add(a,b,c); } int t=spfa(); if(t==-2147483647) cout<<\"impossible\"<<endl; else cout<<t<<endl; return 0; }","title":"\u57fa\u7840spfa"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/spfafu/","text":"spfa \u5224\u65ad\u8d1f\u73af #include<bits/stdc++.h> using namespace std; typedef pair<int,int> PII; const int N=110010; int n,m; int h[N],w[N],e[N],ne[N],idx=0; int dist[N],cnt[N]; bool st[N]; void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } int spfa(){ queue<int> q; for(int i=1;i<=n;i++){ st[i]=true; q.push(i); } while(q.size()){ int t=q.front(); q.pop(); st[t]=false; for(int i=h[t];i!=-1;i=ne[i]){ int j=e[i]; if(dist[j]>dist[t]+w[i]){ dist[j]=dist[t]+w[i]; cnt[j]=cnt[t]+1; if(cnt[t]>=n) return true; if(!st[j]){ q.push(j); st[j]=true; } } } } return false; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); while(m--){ int a,b,c; cin>>a>>b>>c; add(a,b,c); } if(spfa()) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl; return 0; }","title":"spfa \u5224\u65ad\u8d1f\u73af"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/spfafu/#spfa","text":"#include<bits/stdc++.h> using namespace std; typedef pair<int,int> PII; const int N=110010; int n,m; int h[N],w[N],e[N],ne[N],idx=0; int dist[N],cnt[N]; bool st[N]; void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } int spfa(){ queue<int> q; for(int i=1;i<=n;i++){ st[i]=true; q.push(i); } while(q.size()){ int t=q.front(); q.pop(); st[t]=false; for(int i=h[t];i!=-1;i=ne[i]){ int j=e[i]; if(dist[j]>dist[t]+w[i]){ dist[j]=dist[t]+w[i]; cnt[j]=cnt[t]+1; if(cnt[t]>=n) return true; if(!st[j]){ q.push(j); st[j]=true; } } } } return false; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); while(m--){ int a,b,c; cin>>a>>b>>c; add(a,b,c); } if(spfa()) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl; return 0; }","title":"spfa \u5224\u65ad\u8d1f\u73af"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/spfafunb/","text":"spfa\u5224\u8d1f\u73af\u4f18\u5316 #include<bits/stdc++.h> using namespace std; const int N=700,M=100010; int n; int h[N],e[M],w[M],ne[M],idx; double dist[N]; int q[N],cnt[N]; bool st[N]; void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } bool check(double mid){ memset(st,0,sizeof(st)); memset(cnt,0,sizeof(cnt)); memset(dist,0,sizeof(dist)); int hh=0,tt=0; for(int i=0;i<676;i++){ q[tt++]=i; st[i]=true; } int count=0; while(hh!=tt){ int t=q[--tt]; st[t]=false; for(int i=h[t];~i;i=ne[i]){ int j=e[i]; if(dist[j]<dist[t]+w[i]-mid){ dist[j]=dist[t]+w[i]-mid; cnt[j]=cnt[t]+1; if(cnt[j]>=N) return true; if(!st[j]){ q[tt++]=j; st[j]=true; } } } } return false; } int main(){ char str[1010]; while(cin>>n,n){ memset(h,-1,sizeof(h)); idx=0; for(int i=0;i<n;i++){ cin>>str; int len=strlen(str); if(len>=2){ int left=(str[0]-'a')*26+str[1]-'a'; int right=(str[len-2]-'a')*26+str[len-1]-'a'; add(left,right,len); } } if(!check(0)) cout<<\"No solution\"<<endl; else{ double l=0,r=1000; while(r-l>1e-4){ double mid=(l+r)/2; if(check(mid)) l=mid; else r=mid; } printf(\"%.2lf\\n\",l); } } return 0; }","title":"spfa\u5224\u8d1f\u73af\u4f18\u5316"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/spfafunb/#spfa","text":"#include<bits/stdc++.h> using namespace std; const int N=700,M=100010; int n; int h[N],e[M],w[M],ne[M],idx; double dist[N]; int q[N],cnt[N]; bool st[N]; void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } bool check(double mid){ memset(st,0,sizeof(st)); memset(cnt,0,sizeof(cnt)); memset(dist,0,sizeof(dist)); int hh=0,tt=0; for(int i=0;i<676;i++){ q[tt++]=i; st[i]=true; } int count=0; while(hh!=tt){ int t=q[--tt]; st[t]=false; for(int i=h[t];~i;i=ne[i]){ int j=e[i]; if(dist[j]<dist[t]+w[i]-mid){ dist[j]=dist[t]+w[i]-mid; cnt[j]=cnt[t]+1; if(cnt[j]>=N) return true; if(!st[j]){ q[tt++]=j; st[j]=true; } } } } return false; } int main(){ char str[1010]; while(cin>>n,n){ memset(h,-1,sizeof(h)); idx=0; for(int i=0;i<n;i++){ cin>>str; int len=strlen(str); if(len>=2){ int left=(str[0]-'a')*26+str[1]-'a'; int right=(str[len-2]-'a')*26+str[len-1]-'a'; add(left,right,len); } } if(!check(0)) cout<<\"No solution\"<<endl; else{ double l=0,r=1000; while(r-l>1e-4){ double mid=(l+r)/2; if(check(mid)) l=mid; else r=mid; } printf(\"%.2lf\\n\",l); } } return 0; }","title":"spfa\u5224\u8d1f\u73af\u4f18\u5316"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/taijan/","text":"tarjan\u79bb\u7ebf\u6c42\u6700\u8fd1\u516c\u5171\u7956\u5148 #include<bits/stdc++.h> using namespace std; const int N=20010,M=N*2; typedef pair<int,int> PII; int n,m; int h[N],e[M],w[M],ne[M],idx; int dist[N]; int p[N]; int res[N]; int st[N]; vector<PII> query[N];//first\u5b58\u53e6\u4e00\u4e2a\u70b9\uff0csecond\u5b58\u67e5\u8be2\u7f16\u53f7 void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } void dfs(int u,int fa){ for(int i=h[u];~i;i=ne[i]){ int j=e[i]; if(j==fa) continue; dist[j]=dist[u]+w[i]; dfs(j,u); } } int find(int x){ if(p[x]!=x) p[x]=find(p[x]); return p[x]; } void tarjan(int u){ st[u]=1; for(int i=h[u];~i;i=ne[i]){ int j=e[i]; if(!st[j]){ tarjan(j); p[j]=u; } } for(auto item:query[u]){ int y=item.first,id=item.second; if(st[y]==2){ int anc=find(y); res[id]=dist[u]+dist[y]-dist[anc]*2; } } st[u]=2; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); for(int i=0;i<n-1;i++){ int a,b,c; cin>>a>>b>>c; add(a,b,c),add(b,a,c); } for(int i=0;i<m;i++){ int a,b; cin>>a>>b; if(a!=b){ query[a].push_back({b,i}); query[b].push_back({a,i}); } } for(int i=1;i<=n;i++){ p[i]=i; } dfs(1,-1); tarjan(1); for(int i=0;i<m;i++){ cout<<res[i]<<endl; } return 0; }","title":"tarjan\u79bb\u7ebf\u6c42\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/taijan/#tarjan","text":"#include<bits/stdc++.h> using namespace std; const int N=20010,M=N*2; typedef pair<int,int> PII; int n,m; int h[N],e[M],w[M],ne[M],idx; int dist[N]; int p[N]; int res[N]; int st[N]; vector<PII> query[N];//first\u5b58\u53e6\u4e00\u4e2a\u70b9\uff0csecond\u5b58\u67e5\u8be2\u7f16\u53f7 void add(int a,int b,int c){ e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } void dfs(int u,int fa){ for(int i=h[u];~i;i=ne[i]){ int j=e[i]; if(j==fa) continue; dist[j]=dist[u]+w[i]; dfs(j,u); } } int find(int x){ if(p[x]!=x) p[x]=find(p[x]); return p[x]; } void tarjan(int u){ st[u]=1; for(int i=h[u];~i;i=ne[i]){ int j=e[i]; if(!st[j]){ tarjan(j); p[j]=u; } } for(auto item:query[u]){ int y=item.first,id=item.second; if(st[y]==2){ int anc=find(y); res[id]=dist[u]+dist[y]-dist[anc]*2; } } st[u]=2; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); for(int i=0;i<n-1;i++){ int a,b,c; cin>>a>>b>>c; add(a,b,c),add(b,a,c); } for(int i=0;i<m;i++){ int a,b; cin>>a>>b; if(a!=b){ query[a].push_back({b,i}); query[b].push_back({a,i}); } } for(int i=1;i<=n;i++){ p[i]=i; } dfs(1,-1); tarjan(1); for(int i=0;i<m;i++){ cout<<res[i]<<endl; } return 0; }","title":"tarjan\u79bb\u7ebf\u6c42\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/tarjan/","text":"tarjan\u6c42\u5f3a\u8fde\u901a\u5206\u91cf \u5f3a\u8fde\u901a\u5206\u91cf\u4ee3\u8868\u8fd9\u4e00\u5806\u70b9\u4efb\u610fa\u53ef\u4ee5\u8d70\u5230\u4efb\u610fb\uff0c\u6c42\u5b8c\u5f3a\u8fde\u901a\u5206\u91cf\u540e\u53ef\u4ee5\u5c06\u8fd9\u4e9b\u70b9\u7f29\u4e3a\u4e00\u4e2a\u70b9 #include<bits/stdc++.h> using namespace std; const int N=10010,M=50010; int n,m; int h[N],e[M],ne[M],idx; int dfn[N],low[N],timestamp; int stk[N],top; bool in_stk[N]; int id[N],scc_cnt,siz[N]; int dout[N]; void tarjan(int u){ dfn[u] = low[u] = ++timestamp; stk[++top] = u,in_stk[u] = true; for(int i = h[u];~i;i = ne[i]){ int j=e[i]; if(!dfn[j]){ tarjan(j); low[u] = min(low[u],low[j]); } else if(in_stk[j]){ low[u] = min(low[u],low[j]); } } if(dfn[u] == low[u]){ int y; ++ scc_cnt; do{ y=stk[top--]; in_stk[y] = false; id[y] = scc_cnt; siz[scc_cnt]++; }while(y != u); } } void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); while(m--){ int a,b; cin>>a>>b; add(a,b); } for(int i=1;i<=n;i++){ if(!dfn[i]){ tarjan(i); } } for(int i=1;i<=n;i++){ for(int j=h[i];~j;j=ne[j]){ int k= e[j]; int a=id[i],b=id[k]; if(a!=b) dout[a]++; } } int zeros=0,sum=0; for(int i=1;i<=scc_cnt;i++){ if(!dout[i]){ zeros++; sum+=siz[i]; if(zeros>1){ sum=0; break; } } } cout<<sum<<endl; return 0; }","title":"tarjan\u6c42\u5f3a\u8fde\u901a\u5206\u91cf"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/tarjan/#tarjan","text":"\u5f3a\u8fde\u901a\u5206\u91cf\u4ee3\u8868\u8fd9\u4e00\u5806\u70b9\u4efb\u610fa\u53ef\u4ee5\u8d70\u5230\u4efb\u610fb\uff0c\u6c42\u5b8c\u5f3a\u8fde\u901a\u5206\u91cf\u540e\u53ef\u4ee5\u5c06\u8fd9\u4e9b\u70b9\u7f29\u4e3a\u4e00\u4e2a\u70b9 #include<bits/stdc++.h> using namespace std; const int N=10010,M=50010; int n,m; int h[N],e[M],ne[M],idx; int dfn[N],low[N],timestamp; int stk[N],top; bool in_stk[N]; int id[N],scc_cnt,siz[N]; int dout[N]; void tarjan(int u){ dfn[u] = low[u] = ++timestamp; stk[++top] = u,in_stk[u] = true; for(int i = h[u];~i;i = ne[i]){ int j=e[i]; if(!dfn[j]){ tarjan(j); low[u] = min(low[u],low[j]); } else if(in_stk[j]){ low[u] = min(low[u],low[j]); } } if(dfn[u] == low[u]){ int y; ++ scc_cnt; do{ y=stk[top--]; in_stk[y] = false; id[y] = scc_cnt; siz[scc_cnt]++; }while(y != u); } } void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++; } int main(){ cin>>n>>m; memset(h,-1,sizeof(h)); while(m--){ int a,b; cin>>a>>b; add(a,b); } for(int i=1;i<=n;i++){ if(!dfn[i]){ tarjan(i); } } for(int i=1;i<=n;i++){ for(int j=h[i];~j;j=ne[j]){ int k= e[j]; int a=id[i],b=id[k]; if(a!=b) dout[a]++; } } int zeros=0,sum=0; for(int i=1;i<=scc_cnt;i++){ if(!dout[i]){ zeros++; sum+=siz[i]; if(zeros>1){ sum=0; break; } } } cout<<sum<<endl; return 0; }","title":"tarjan\u6c42\u5f3a\u8fde\u901a\u5206\u91cf"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/topsort/","text":"\u62d3\u6251\u6392\u5e8f\u6a21\u677f int h[N],e[N],ne[N],idx; int q[N],d[N];//\u961f\u5217\u91cc\u540c\u65f6\u5b58\u7740\u62d3\u6251\u5e8f void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++; } bool topsort(){ int hh=0,tt=-1; for(int i=1;i<=n;i++){ if(!d[i]) q[++tt]=i; } while(hh<=tt){ int t=q[hh++]; for(int i=h[t];i!=-1;i=ne[i]){ int j=e[i]; d[j]--; if(d[j]==0) q[++tt]=j; } } return tt==n-1; }","title":"\u62d3\u6251\u6392\u5e8f\u6a21\u677f"},{"location":"algorithms/%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF/topsort/#_1","text":"int h[N],e[N],ne[N],idx; int q[N],d[N];//\u961f\u5217\u91cc\u540c\u65f6\u5b58\u7740\u62d3\u6251\u5e8f void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++; } bool topsort(){ int hh=0,tt=-1; for(int i=1;i<=n;i++){ if(!d[i]) q[++tt]=i; } while(hh<=tt){ int t=q[hh++]; for(int i=h[t];i!=-1;i=ne[i]){ int j=e[i]; d[j]--; if(d[j]==0) q[++tt]=j; } } return tt==n-1; }","title":"\u62d3\u6251\u6392\u5e8f\u6a21\u677f"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/bcj/","text":"\u5e76\u67e5\u96c6 int p[N]; void init(){ for(int i=1;i<=n;i++){ p[i]=i; } return; } int find(int x){//\u52a0\u4e0a\u8def\u5f84\u538b\u7f29 if(p[x]!=x) p[x]=find(p[x]); return p[x]; } //------------------------------------- if(op[0]=='M') p[find(a)]=find(b); else{ if(find(a)==find(b)) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl; }","title":"\u5e76\u67e5\u96c6"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/bcj/#_1","text":"int p[N]; void init(){ for(int i=1;i<=n;i++){ p[i]=i; } return; } int find(int x){//\u52a0\u4e0a\u8def\u5f84\u538b\u7f29 if(p[x]!=x) p[x]=find(p[x]); return p[x]; } //------------------------------------- if(op[0]=='M') p[find(a)]=find(b); else{ if(find(a)==find(b)) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl; }","title":"\u5e76\u67e5\u96c6"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/dingli/","text":"\u5b9a\u7406","title":"\u5b9a\u7406"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/dingli/#_1","text":"","title":"\u5b9a\u7406"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/dl/","text":"\u624b\u5199\u961f\u5217 int q[N],hh,tt=-1; //\u589e\u52a0\u5143\u7d20 q[++tt]=x; //\u5f39\u51fa\u961f\u9996\u5143\u7d20 hh++; //\u5224\u65ad\u662f\u4e0d\u662f\u7a7a if(hh<=tt) not empty else empty; //\u8bbf\u95ee\u961f\u9996\u5143\u7d20 stk[hh];","title":"\u624b\u5199\u961f\u5217"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/dl/#_1","text":"int q[N],hh,tt=-1; //\u589e\u52a0\u5143\u7d20 q[++tt]=x; //\u5f39\u51fa\u961f\u9996\u5143\u7d20 hh++; //\u5224\u65ad\u662f\u4e0d\u662f\u7a7a if(hh<=tt) not empty else empty; //\u8bbf\u95ee\u961f\u9996\u5143\u7d20 stk[hh];","title":"\u624b\u5199\u961f\u5217"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/dlb/","text":"\u624b\u5199\u5355\u94fe\u8868 int head,e[N],ne[N],idx; void init(){ head=-1; idx=0; } //\u5c06x\u63d2\u5165\u5934 void add_to_head(int x){ e[idx]=x,ne[idx]=head,head=idx,idx++; } //\u5c06x\u63d2\u5165k\u540e\u9762 void add(int k,int x){ e[idx]=x; ne[idx]=ne[k]; ne[k]=idx; idx++; } //\u5c06\u4e0b\u6807\u662fk\u540e\u9762\u7684\u5143\u7d20\u5220\u6389 void remove(int k){ ne[k]=ne[ne[k]]; }","title":"\u624b\u5199\u5355\u94fe\u8868"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/dlb/#_1","text":"int head,e[N],ne[N],idx; void init(){ head=-1; idx=0; } //\u5c06x\u63d2\u5165\u5934 void add_to_head(int x){ e[idx]=x,ne[idx]=head,head=idx,idx++; } //\u5c06x\u63d2\u5165k\u540e\u9762 void add(int k,int x){ e[idx]=x; ne[idx]=ne[k]; ne[k]=idx; idx++; } //\u5c06\u4e0b\u6807\u662fk\u540e\u9762\u7684\u5143\u7d20\u5220\u6389 void remove(int k){ ne[k]=ne[ne[k]]; }","title":"\u624b\u5199\u5355\u94fe\u8868"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/dui/","text":"\u624b\u5199\u5806\u548c\u5e26\u6620\u5c04\u7684\u5806 //\u624b\u5199\u5806 int n,m; int h[N],sizes; void down(int u){ int t=u; if(u*2<=sizes && h[u*2]<h[t]) t=u*2; if(u*2+1<=sizes && h[u*2+1]<h[t]) t=u*2+1; if(u!=t){ swap(h[u],h[t]); down(t); } return; } void up(int u){ while(u/2 && h[u/2]>h[u]){ swap(h[u/2],h[u]); u=u/2; } return; } //--------------------------------------- sizes=n; for(int i=n/2;i>0;i--){ down(i); } while(m--){ cout<<h[1]<<\" \"; h[1]=h[sizes]; sizes--; down(1); } //\u624b\u5199\u5e26\u6620\u5c04\u7684\u5806 #include<bits/stdc++.h> using namespace std; const int N=1e5+10; int n,m; int ph[N],hp[N]; int h[N],sizes; void heap_swap(int a,int b){ swap(ph[hp[a]],ph[hp[b]]); swap(hp[a],hp[b]); swap(h[a],h[b]); } void down(int u){ int t=u; if(u*2<=sizes && h[u*2]<h[t]) t=u*2; if(u*2+1<=sizes && h[u*2+1]<h[t]) t=u*2+1; if(u!=t){ heap_swap(u,t); down(t); } return; } void up(int u){ while(u/2 && h[u/2]>h[u]){ heap_swap(u/2,u); u=u/2; } return; } int main(){ cin>>n; while(n--){ char op[10]; int k,x; cin>>op; if(op[0]=='I'){ cin>>x; sizes++; m++; ph[m]=sizes,hp[sizes]=m; h[sizes]=x; up(sizes); } else if(op[0]=='P'){ cout<<h[1]<<endl; } else if(op[1]=='M'){ heap_swap(1,sizes); sizes--; down(1); } else if(op[0]=='D'){ cin>>k; k=hp[k]; heap_swap(k,sizes); sizes--; down(k),up(k); } else{ cin>>k>>x; k=ph[k]; h[k]=x; down(k),up(k); } } return 0; }","title":"\u624b\u5199\u5806\u548c\u5e26\u6620\u5c04\u7684\u5806"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/dui/#_1","text":"//\u624b\u5199\u5806 int n,m; int h[N],sizes; void down(int u){ int t=u; if(u*2<=sizes && h[u*2]<h[t]) t=u*2; if(u*2+1<=sizes && h[u*2+1]<h[t]) t=u*2+1; if(u!=t){ swap(h[u],h[t]); down(t); } return; } void up(int u){ while(u/2 && h[u/2]>h[u]){ swap(h[u/2],h[u]); u=u/2; } return; } //--------------------------------------- sizes=n; for(int i=n/2;i>0;i--){ down(i); } while(m--){ cout<<h[1]<<\" \"; h[1]=h[sizes]; sizes--; down(1); } //\u624b\u5199\u5e26\u6620\u5c04\u7684\u5806 #include<bits/stdc++.h> using namespace std; const int N=1e5+10; int n,m; int ph[N],hp[N]; int h[N],sizes; void heap_swap(int a,int b){ swap(ph[hp[a]],ph[hp[b]]); swap(hp[a],hp[b]); swap(h[a],h[b]); } void down(int u){ int t=u; if(u*2<=sizes && h[u*2]<h[t]) t=u*2; if(u*2+1<=sizes && h[u*2+1]<h[t]) t=u*2+1; if(u!=t){ heap_swap(u,t); down(t); } return; } void up(int u){ while(u/2 && h[u/2]>h[u]){ heap_swap(u/2,u); u=u/2; } return; } int main(){ cin>>n; while(n--){ char op[10]; int k,x; cin>>op; if(op[0]=='I'){ cin>>x; sizes++; m++; ph[m]=sizes,hp[sizes]=m; h[sizes]=x; up(sizes); } else if(op[0]=='P'){ cout<<h[1]<<endl; } else if(op[1]=='M'){ heap_swap(1,sizes); sizes--; down(1); } else if(op[0]=='D'){ cin>>k; k=hp[k]; heap_swap(k,sizes); sizes--; down(k),up(k); } else{ cin>>k>>x; k=ph[k]; h[k]=x; down(k),up(k); } } return 0; }","title":"\u624b\u5199\u5806\u548c\u5e26\u6620\u5c04\u7684\u5806"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/erfen/","text":"\u4e8c\u5206\u641c\u7d22\u6a21\u677f //\u627e\u6700\u540e\u4e00\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u5143\u7d20 while(ll<rr){ int mid=(ll+rr+1)/2; if(chk(mid)){ ll=mid; } else{ rr=mid-1; } } //\u627e\u7b2c\u4e00\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u5143\u7d20 while(ll<rr){ int mid=(ll+rr)/2; if(chk(mid)){ rr=mid; } else{s ll=mid+1; } }","title":"\u4e8c\u5206\u641c\u7d22\u6a21\u677f"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/erfen/#_1","text":"//\u627e\u6700\u540e\u4e00\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u5143\u7d20 while(ll<rr){ int mid=(ll+rr+1)/2; if(chk(mid)){ ll=mid; } else{ rr=mid-1; } } //\u627e\u7b2c\u4e00\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u5143\u7d20 while(ll<rr){ int mid=(ll+rr)/2; if(chk(mid)){ rr=mid; } else{s ll=mid+1; } }","title":"\u4e8c\u5206\u641c\u7d22\u6a21\u677f"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/haxi/","text":"\u94fe\u8868\u6cd5\u54c8\u5e0c int h[N],e[N],ne[N],idx; void insert(int x){ int k=(x%N+N)%N; e[idx]=x; ne[idx]=h[k]; h[k]=idx++; } bool find(int x){ int k=(x%N+N)%N; for(int i=h[k];i!=-1;i=ne[i]){ if(e[i]==x){ return true; } } return false; }","title":"\u94fe\u8868\u6cd5\u54c8\u5e0c"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/haxi/#_1","text":"int h[N],e[N],ne[N],idx; void insert(int x){ int k=(x%N+N)%N; e[idx]=x; ne[idx]=h[k]; h[k]=idx++; } bool find(int x){ int k=(x%N+N)%N; for(int i=h[k];i!=-1;i=ne[i]){ if(e[i]==x){ return true; } } return false; }","title":"\u94fe\u8868\u6cd5\u54c8\u5e0c"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/int128/","text":"int128\u8f93\u5165\u8f93\u51fa\u6a21\u677f __int128 read(){ __int128 res=0; char scan[1005]; scanf(\"%s\",scan); for(int i=0;i<strlen(scan);i++){ res*=10; res=res+scan[i]-'0'; } return res; } void print(__int128 num){ if(num>9) print(num/10); putchar(num%10+'0'); }","title":"int128\u8f93\u5165\u8f93\u51fa\u6a21\u677f"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/int128/#int128","text":"__int128 read(){ __int128 res=0; char scan[1005]; scanf(\"%s\",scan); for(int i=0;i<strlen(scan);i++){ res*=10; res=res+scan[i]-'0'; } return res; } void print(__int128 num){ if(num>9) print(num/10); putchar(num%10+'0'); }","title":"int128\u8f93\u5165\u8f93\u51fa\u6a21\u677f"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/jqbcj/","text":"\u52a0\u6743\u5e76\u67e5\u96c6 int p[N],sizes[N]; void init(){ for(int i=1;i<=n;i++){ p[i]=i; sizes[i]=1; } return; } int find(int x){//\u52a0\u4e0a\u8def\u5f84\u538b\u7f29 if(p[x]!=x) p[x]=find(p[x]); return p[x]; } //--------------------------- cin>>op; if(op[0]=='C'){ cin>>a>>b; if(find(a)==find(b)) continue; sizes[find(b)]+=sizes[find(a)]; p[find(a)]=find(b); } else if(op[1]=='1'){ cin>>a>>b; if(find(a)==find(b)) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl; } else{ cin>>a; cout<<sizes[find(a)]<<endl; }","title":"\u52a0\u6743\u5e76\u67e5\u96c6"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/jqbcj/#_1","text":"int p[N],sizes[N]; void init(){ for(int i=1;i<=n;i++){ p[i]=i; sizes[i]=1; } return; } int find(int x){//\u52a0\u4e0a\u8def\u5f84\u538b\u7f29 if(p[x]!=x) p[x]=find(p[x]); return p[x]; } //--------------------------- cin>>op; if(op[0]=='C'){ cin>>a>>b; if(find(a)==find(b)) continue; sizes[find(b)]+=sizes[find(a)]; p[find(a)]=find(b); } else if(op[1]=='1'){ cin>>a>>b; if(find(a)==find(b)) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl; } else{ cin>>a; cout<<sizes[find(a)]<<endl; }","title":"\u52a0\u6743\u5e76\u67e5\u96c6"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/juzhen/","text":"\u77e9\u9635\u4e58\u6cd5 void mul(int c[][N],int a[][N],int b[][N]){ int t[N][N]; memset(t,0,sizeof(t)); for(int i=0;i<m;i++){ for(int j=0;j<m;j++){ for(int k=0;k<m;k++){ t[i][j]=(t[i][j]+a[i][k]*b[k][j])%mod; } } } memcpy(c,t,sizeof(t)); }","title":"\u77e9\u9635\u4e58\u6cd5"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/juzhen/#_1","text":"void mul(int c[][N],int a[][N],int b[][N]){ int t[N][N]; memset(t,0,sizeof(t)); for(int i=0;i<m;i++){ for(int j=0;j<m;j++){ for(int k=0;k<m;k++){ t[i][j]=(t[i][j]+a[i][k]*b[k][j])%mod; } } } memcpy(c,t,sizeof(t)); }","title":"\u77e9\u9635\u4e58\u6cd5"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/juzhenqsm/","text":"\u77e9\u9635\u5feb\u901f\u5e42 int g[N][N]; int res[N][N]; void mul(int c[][N],int a[][N],int b[][N]){ static int temp[N][N]; memset(temp,0x3f,sizeof(temp)); for(int k=1;k<=n;k++){ for(int i=1;i<=n;i++){ for(int j=1;j<=n;j++){ temp[i][j]=min(temp[i][j],a[i][k]+b[k][j]); } } } memcpy(c,temp,sizeof(temp)); } void qmi(){ memset(res,0x3f,sizeof(res)); for(int i=1;i<=n;i++){ res[i][i]=0; } while(k){ if(k&1) mul(res,res,g); mul(g,g,g); k>>=1; } }","title":"\u77e9\u9635\u5feb\u901f\u5e42"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/juzhenqsm/#_1","text":"int g[N][N]; int res[N][N]; void mul(int c[][N],int a[][N],int b[][N]){ static int temp[N][N]; memset(temp,0x3f,sizeof(temp)); for(int k=1;k<=n;k++){ for(int i=1;i<=n;i++){ for(int j=1;j<=n;j++){ temp[i][j]=min(temp[i][j],a[i][k]+b[k][j]); } } } memcpy(c,temp,sizeof(temp)); } void qmi(){ memset(res,0x3f,sizeof(res)); for(int i=1;i<=n;i++){ res[i][i]=0; } while(k){ if(k&1) mul(res,res,g); mul(g,g,g); k>>=1; } }","title":"\u77e9\u9635\u5feb\u901f\u5e42"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/operator/","text":"\u91cd\u8f7d\u8fd0\u7b97\u7b26 bool operator<(const node& x) const{ return a>x.a; }","title":"\u91cd\u8f7d\u8fd0\u7b97\u7b26"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/operator/#_1","text":"bool operator<(const node& x) const{ return a>x.a; }","title":"\u91cd\u8f7d\u8fd0\u7b97\u7b26"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/qsm/","text":"\u5feb\u901f\u5e42\u6a21\u677f ll qsm(ll a,ll b){ ll res=1; while(b){ if(b&1) res=(res*a)%mod; a=(a*a)%mod; b>>=1; } return res; }","title":"\u5feb\u901f\u5e42\u6a21\u677f"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/qsm/#_1","text":"ll qsm(ll a,ll b){ ll res=1; while(b){ if(b&1) res=(res*a)%mod; a=(a*a)%mod; b>>=1; } return res; }","title":"\u5feb\u901f\u5e42\u6a21\u677f"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/slb/","text":"\u624b\u5199\u53cc\u94fe\u8868 int l[N],r[N],e[N]; //0->head,1->tail void init(){ r[0]=1; l[1]=0; idx=2; } void add(int k,int x){ e[idx]=x; r[idx]=r[k]; l[idx]=k; l[r[k]]=idx; r[k]=idx; idx++; } void remove(int k){ r[l[k]]=r[k]; l[r[k]]=l[k]; }","title":"\u624b\u5199\u53cc\u94fe\u8868"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/slb/#_1","text":"int l[N],r[N],e[N]; //0->head,1->tail void init(){ r[0]=1; l[1]=0; idx=2; } void add(int k,int x){ e[idx]=x; r[idx]=r[k]; l[idx]=k; l[r[k]]=idx; r[k]=idx; idx++; } void remove(int k){ r[l[k]]=r[k]; l[r[k]]=l[k]; }","title":"\u624b\u5199\u53cc\u94fe\u8868"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/stl/","text":"stl\u5e93 vector vector<int> a(10,3);//\u5b9a\u4e49\u4e00\u4e2a\u957f\u5ea6\u4e3a10\u7684vector\uff0c\u5176\u6bcf\u4e2a\u5143\u7d20\u90fd\u662f3 a.size(),a.empty();//\u65f6\u95f4\u590d\u6742\u5ea6 O(1) a.clear() a.front()//\u8fd4\u56de\u7b2c\u4e00\u4e2a\u6570 a.back()//\u8fd4\u56de\u6700\u540e\u4e00\u4e2a\u6570 a.push_back(),a.pop_back(); a.begin(),a.back()//\u8fd4\u56de\u5934\u5c3e\u6307\u9488 vector\u652f\u6301\u6bd4\u8f83\u64cd\u4f5c\uff0c\u6309\u5b57\u5178\u5e8f\u6392\u5e8f pair<int,string> first //\u7b2c\u4e00\u4e2a\u5143\u7d20 second //\u7b2c\u4e8c\u4e2a\u5143\u7d20 \u652f\u6301\u6bd4\u8f83\u64cd\u4f5c\uff0cfirst\u7b2c\u4e00\u5173\u952e\u5b57\uff0csecond\u7b2c\u4e8c\u5173\u952e\u5b57 p={20,\"abc\"}; string string a=\"abc\"; a+=\"def\"; a+=\"c\"; a.substr(1,2);//i\u4e0b\u6807\u5f00\u59cb\uff0c\u5171\u8fd4\u56de\u4e24\u4e2a\u5b57\u7b26\uff0c\u7701\u7565\u7b2c\u4e8c\u4e2a\u6570\uff0c\u5219\u662f\u4ecei\u5f00\u59cb\u8f93\u51fa\u5b8c a.c_str()//\u5b58\u50a8\u5b57\u7b26\u6570\u7ec4\u7684\u8d77\u59cb\u5730 queue size(),empty(),push(),front(),pop(),back(); priority_queue push(),top(),pop(); stack push(),top(),pop(); deque//\u53cc\u7aef\u961f\u5217 size(),empty(),clear(),front(),back(),push_back(),pop_back(),push_front(), pop_front() set,map,multiset,multimap size(),empty(),clear() set/multiset insert() find() count() erase()//\u8f93\u5165\u4e00\u4e2a\u6570x\uff0c\u5220\u9664\u6240\u6709x\u6216\u8005\u8f93\u5165\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u5220\u9664\u8fd9\u4e2a\u8fed\u4ee3\u5668 lower_bound()/upper_bound() lower_bound//\u8fd4\u56de\u5927\u4e8e\u7b49\u4e8ex\u7684\u6700\u5c0f\u7684\u8fed\u4ee3\u5668 upper_bound//\u8fd4\u56de\u5927\u4e8ex\u7684\u6700\u5c0f\u7684\u8fed\u4ee3\u5668 map/multimap insert() erase() find() lower_bound()/upper_bound() unordered_set,unordered_map,unordered_multiset,unordered_multimap \u548c\u4e0a\u9762\u64cd\u4f5c\u7c7b\u4f3c\uff0c\u589e\u5220\u6539\u67e5\u64cd\u4f5c\u590d\u6742\u5ea6\u4e3aO(1) \u4e0d\u652f\u6301lower_bound()/upper_bound() bitset,\u538b\u4f4d bitset<10000> s; ~ & | ^ >>, << ==, != [] count() \u8fd4\u56de\u6709\u591a\u5c11\u4e2a1 any()//\u8fd4\u56de\u662f\u5426\u81f3\u5c11\u6709\u4e00\u4e2a1 none()//\u8fd4\u56de\u662f\u5426\u5168\u4e3a\u7a7a set()//\u628a\u6240\u6709\u4f4d\u7f6e\u62101 set(k,v)//\u5c06\u7b2ck\u4f4d\u53d8\u6210v reset()//\u628a\u6240\u6709\u4f4d\u53d8\u62100 flip()//\u628a\u6240\u6709\u4f4d\u53d6\u53cd\uff0c\u7b49\u4ef7\u4e8e~ flip(k)//\u7b2ck\u4f4d\u53d6\u53cd","title":"stl\u5e93"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/stl/#stl","text":"vector vector<int> a(10,3);//\u5b9a\u4e49\u4e00\u4e2a\u957f\u5ea6\u4e3a10\u7684vector\uff0c\u5176\u6bcf\u4e2a\u5143\u7d20\u90fd\u662f3 a.size(),a.empty();//\u65f6\u95f4\u590d\u6742\u5ea6 O(1) a.clear() a.front()//\u8fd4\u56de\u7b2c\u4e00\u4e2a\u6570 a.back()//\u8fd4\u56de\u6700\u540e\u4e00\u4e2a\u6570 a.push_back(),a.pop_back(); a.begin(),a.back()//\u8fd4\u56de\u5934\u5c3e\u6307\u9488 vector\u652f\u6301\u6bd4\u8f83\u64cd\u4f5c\uff0c\u6309\u5b57\u5178\u5e8f\u6392\u5e8f pair<int,string> first //\u7b2c\u4e00\u4e2a\u5143\u7d20 second //\u7b2c\u4e8c\u4e2a\u5143\u7d20 \u652f\u6301\u6bd4\u8f83\u64cd\u4f5c\uff0cfirst\u7b2c\u4e00\u5173\u952e\u5b57\uff0csecond\u7b2c\u4e8c\u5173\u952e\u5b57 p={20,\"abc\"}; string string a=\"abc\"; a+=\"def\"; a+=\"c\"; a.substr(1,2);//i\u4e0b\u6807\u5f00\u59cb\uff0c\u5171\u8fd4\u56de\u4e24\u4e2a\u5b57\u7b26\uff0c\u7701\u7565\u7b2c\u4e8c\u4e2a\u6570\uff0c\u5219\u662f\u4ecei\u5f00\u59cb\u8f93\u51fa\u5b8c a.c_str()//\u5b58\u50a8\u5b57\u7b26\u6570\u7ec4\u7684\u8d77\u59cb\u5730 queue size(),empty(),push(),front(),pop(),back(); priority_queue push(),top(),pop(); stack push(),top(),pop(); deque//\u53cc\u7aef\u961f\u5217 size(),empty(),clear(),front(),back(),push_back(),pop_back(),push_front(), pop_front() set,map,multiset,multimap size(),empty(),clear() set/multiset insert() find() count() erase()//\u8f93\u5165\u4e00\u4e2a\u6570x\uff0c\u5220\u9664\u6240\u6709x\u6216\u8005\u8f93\u5165\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u5220\u9664\u8fd9\u4e2a\u8fed\u4ee3\u5668 lower_bound()/upper_bound() lower_bound//\u8fd4\u56de\u5927\u4e8e\u7b49\u4e8ex\u7684\u6700\u5c0f\u7684\u8fed\u4ee3\u5668 upper_bound//\u8fd4\u56de\u5927\u4e8ex\u7684\u6700\u5c0f\u7684\u8fed\u4ee3\u5668 map/multimap insert() erase() find() lower_bound()/upper_bound() unordered_set,unordered_map,unordered_multiset,unordered_multimap \u548c\u4e0a\u9762\u64cd\u4f5c\u7c7b\u4f3c\uff0c\u589e\u5220\u6539\u67e5\u64cd\u4f5c\u590d\u6742\u5ea6\u4e3aO(1) \u4e0d\u652f\u6301lower_bound()/upper_bound() bitset,\u538b\u4f4d bitset<10000> s; ~ & | ^ >>, << ==, != [] count() \u8fd4\u56de\u6709\u591a\u5c11\u4e2a1 any()//\u8fd4\u56de\u662f\u5426\u81f3\u5c11\u6709\u4e00\u4e2a1 none()//\u8fd4\u56de\u662f\u5426\u5168\u4e3a\u7a7a set()//\u628a\u6240\u6709\u4f4d\u7f6e\u62101 set(k,v)//\u5c06\u7b2ck\u4f4d\u53d8\u6210v reset()//\u628a\u6240\u6709\u4f4d\u53d8\u62100 flip()//\u628a\u6240\u6709\u4f4d\u53d6\u53cd\uff0c\u7b49\u4ef7\u4e8e~ flip(k)//\u7b2ck\u4f4d\u53d6\u53cd","title":"stl\u5e93"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/zfchx/","text":"\u5b57\u7b26\u4e32\u54c8\u5e0c #include<bits/stdc++.h> using namespace std; typedef unsigned long long ULL; const int N=100010,P=131; int n,m; string str; ULL h[N],p[N]; ULL get(int l,int r){ return h[r]-h[l-1]*p[r-l+1]; } int main(){ cin>>n>>m>>str; str=' '+str; p[0]=1; for(int i=1;i<=n;i++){ p[i]=p[i-1]*P; h[i]=h[i-1]*P+str[i]; } while(m--){ int l1,r1,l2,r2; cin>>l1>>r1>>l2>>r2; if(get(l1,r1)==get(l2,r2)) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl; } return 0; }","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/zfchx/#_1","text":"#include<bits/stdc++.h> using namespace std; typedef unsigned long long ULL; const int N=100010,P=131; int n,m; string str; ULL h[N],p[N]; ULL get(int l,int r){ return h[r]-h[l-1]*p[r-l+1]; } int main(){ cin>>n>>m>>str; str=' '+str; p[0]=1; for(int i=1;i<=n;i++){ p[i]=p[i-1]*P; h[i]=h[i-1]*P+str[i]; } while(m--){ int l1,r1,l2,r2; cin>>l1>>r1>>l2>>r2; if(get(l1,r1)==get(l2,r2)) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl; } return 0; }","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/zhan/","text":"\u624b\u5199\u6808 int stk[N],tt; //\u589e\u52a0\u5143\u7d20 stk[++tt]=x; //\u5f39\u51fa\u6808\u9876\u5143\u7d20 tt--; //\u5224\u65ad\u662f\u4e0d\u662f\u7a7a if(tt>0) not empty else empty //\u8bbf\u95ee\u6808\u9876\u5143\u7d20 stk[tt];","title":"\u624b\u5199\u6808"},{"location":"algorithms/%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/zhan/#_1","text":"int stk[N],tt; //\u589e\u52a0\u5143\u7d20 stk[++tt]=x; //\u5f39\u51fa\u6808\u9876\u5143\u7d20 tt--; //\u5224\u65ad\u662f\u4e0d\u662f\u7a7a if(tt>0) not empty else empty //\u8bbf\u95ee\u6808\u9876\u5143\u7d20 stk[tt];","title":"\u624b\u5199\u6808"},{"location":"algorithms/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF/kmp/","text":"KMP for(int i=2,j=0;i<=n;i++){ while(j && p[i]!=p[j+1]) j=ne[j]; if(p[i]==p[j+1]) j++; ne[i]=j; } //kmp\u5339\u914d\u8fc7\u7a0b for(int i=1,j=0;i<=m;i++){ while(j && s[i]!=p[j+1]) j=ne[j]; if(s[i]==p[j+1]) j++; if(j==n){ //\u5339\u914d\u6210\u529f } } \u6ce8\u610f\u53ef\u4ee5\u7528\u4e8c\u7ef4\u6570\u7ec4\u9884\u5904\u7406\u5982\u679ci\u5904\u4e0d\u5339\u914d\uff0c\u9047\u5230\u7279\u5b9a\u5b57\u7b26c\u9000\u56de\u7684\u4f4d\u7f6e","title":"KMP"},{"location":"algorithms/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF/kmp/#kmp","text":"for(int i=2,j=0;i<=n;i++){ while(j && p[i]!=p[j+1]) j=ne[j]; if(p[i]==p[j+1]) j++; ne[i]=j; } //kmp\u5339\u914d\u8fc7\u7a0b for(int i=1,j=0;i<=m;i++){ while(j && s[i]!=p[j+1]) j=ne[j]; if(s[i]==p[j+1]) j++; if(j==n){ //\u5339\u914d\u6210\u529f } } \u6ce8\u610f\u53ef\u4ee5\u7528\u4e8c\u7ef4\u6570\u7ec4\u9884\u5904\u7406\u5982\u679ci\u5904\u4e0d\u5339\u914d\uff0c\u9047\u5230\u7279\u5b9a\u5b57\u7b26c\u9000\u56de\u7684\u4f4d\u7f6e","title":"KMP"},{"location":"algorithms/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF/trie/","text":"trie\u6811 int son[N][26],cnt[N],idx;//\u4e0b\u6807\u4e3a0\u7684\u8282\u70b9\uff0c\u65e2\u662f\u6839\u8282\u70b9\uff0c\u53c8\u662f\u7a7a\u8282\u70b9 char str[N]; void insert(char str[]){ int p=0; for(int i=0;str[i];i++){ int u=str[i]-'a'; if(!son[p][u]) son[p][u]=++idx; p=son[p][u]; } cnt[p]++; } int query(char str[]){ int p=0; for(int i=0;str[i];i++){ int u=str[i]-'a'; if(!son[p][u]) return 0; p=son[p][u]; } return cnt[p]; }","title":"trie\u6811"},{"location":"algorithms/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF/trie/#trie","text":"int son[N][26],cnt[N],idx;//\u4e0b\u6807\u4e3a0\u7684\u8282\u70b9\uff0c\u65e2\u662f\u6839\u8282\u70b9\uff0c\u53c8\u662f\u7a7a\u8282\u70b9 char str[N]; void insert(char str[]){ int p=0; for(int i=0;str[i];i++){ int u=str[i]-'a'; if(!son[p][u]) son[p][u]=++idx; p=son[p][u]; } cnt[p]++; } int query(char str[]){ int p=0; for(int i=0;str[i];i++){ int u=str[i]-'a'; if(!son[p][u]) return 0; p=son[p][u]; } return cnt[p]; }","title":"trie\u6811"},{"location":"algorithms/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/axing/","text":"a*\u7b97\u6cd5 #include<bits/stdc++.h> #define x first #define y second using namespace std; typedef pair<int,string> PIS; int f(string state){ int res=0; for(int i=0;i<state.size();i++){ if(state[i]!='x'){ int t=state[i]-'1'; res+=abs(i/3-t/3)+abs(i%3-t%3); } } return res; } string bfs(string start){ string end=\"12345678x\"; unordered_map<string,int> dist; unordered_map<string,pair<char,string>> prev; priority_queue<PIS,vector<PIS>,greater<PIS>> heap; dist[start]=0; heap.push({f(start),start}); int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1}; char op[]=\"urdl\"; while(heap.size()){ auto t=heap.top(); heap.pop(); string state=t.y; if(state==end) break; int x,y; for(int i=0;i<9;i++){ if(state[i]=='x'){ x=i/3,y=i%3; break; } } string source=state; for(int i=0;i<4;i++){ int a=x+dx[i],b=y+dy[i]; if(a<0 || a>=3 || b<0 || b>=3) continue; state=source; swap(state[x*3+y],state[a*3+b]); if(dist.count(state) || dist[state]>dist[source]+1){ dist[state]=dist[source]+1; prev[state]={op[i],source}; heap.push({dist[state]+f(state),state}); } } } string res; while(end!=start){ res+=prev[end].x; end=prev[end].y; } reverse(res.begin(),res.end()); return res; } int main(){ string start,seq; char c; while(cin>>c){ start+=c; if(c!='x') seq+=c; } int cnt=0; for(int i=0;i<8;i++){ for(int j=i;j<8;j++){ if(seq[i]>seq[j]){ cnt++; } } } if(cnt & 1) cout<<\"unsolvable\"; else cout<<bfs(start)<<endl; return 0; }","title":"a*\u7b97\u6cd5"},{"location":"algorithms/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/axing/#a","text":"#include<bits/stdc++.h> #define x first #define y second using namespace std; typedef pair<int,string> PIS; int f(string state){ int res=0; for(int i=0;i<state.size();i++){ if(state[i]!='x'){ int t=state[i]-'1'; res+=abs(i/3-t/3)+abs(i%3-t%3); } } return res; } string bfs(string start){ string end=\"12345678x\"; unordered_map<string,int> dist; unordered_map<string,pair<char,string>> prev; priority_queue<PIS,vector<PIS>,greater<PIS>> heap; dist[start]=0; heap.push({f(start),start}); int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1}; char op[]=\"urdl\"; while(heap.size()){ auto t=heap.top(); heap.pop(); string state=t.y; if(state==end) break; int x,y; for(int i=0;i<9;i++){ if(state[i]=='x'){ x=i/3,y=i%3; break; } } string source=state; for(int i=0;i<4;i++){ int a=x+dx[i],b=y+dy[i]; if(a<0 || a>=3 || b<0 || b>=3) continue; state=source; swap(state[x*3+y],state[a*3+b]); if(dist.count(state) || dist[state]>dist[source]+1){ dist[state]=dist[source]+1; prev[state]={op[i],source}; heap.push({dist[state]+f(state),state}); } } } string res; while(end!=start){ res+=prev[end].x; end=prev[end].y; } reverse(res.begin(),res.end()); return res; } int main(){ string start,seq; char c; while(cin>>c){ start+=c; if(c!='x') seq+=c; } int cnt=0; for(int i=0;i<8;i++){ for(int j=i;j<8;j++){ if(seq[i]>seq[j]){ cnt++; } } } if(cnt & 1) cout<<\"unsolvable\"; else cout<<bfs(start)<<endl; return 0; }","title":"a*\u7b97\u6cd5"},{"location":"algorithms/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/bfs/","text":"bfs\u6a21\u677f int n,m; int h[N],e[N],ne[N],idx; int d[N],q[N]; void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++; } int bfs(){ int hh=0,tt=0; q[0]=1; memset(d,-1,sizeof(d)); d[1]=0; while(hh<=tt){ int t=q[hh++]; for(int i=h[t];i!=-1;i=ne[i]){ int j=e[i]; if(d[j]==-1){ d[j]=d[t]+1; q[++tt]=j; } } } return d[n]; }","title":"bfs\u6a21\u677f"},{"location":"algorithms/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/bfs/#bfs","text":"int n,m; int h[N],e[N],ne[N],idx; int d[N],q[N]; void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++; } int bfs(){ int hh=0,tt=0; q[0]=1; memset(d,-1,sizeof(d)); d[1]=0; while(hh<=tt){ int t=q[hh++]; for(int i=h[t];i!=-1;i=ne[i]){ int j=e[i]; if(d[j]==-1){ d[j]=d[t]+1; q[++tt]=j; } } } return d[n]; }","title":"bfs\u6a21\u677f"},{"location":"algorithms/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/idaxing/","text":"idea* #include<bits/stdc++.h> using namespace std; const int N=24; int op[8][7]={ {0,2,6,11,15,20,22}, {1,3,8,12,17,21,23}, {10,9,8,7,6,5,4}, {19,18,17,16,15,14,13}, {23,21,17,12,8,3,1}, {22,20,15,11,6,2,0}, {13,14,15,16,17,18,19}, {4,5,6,7,8,9,10} }; int opposite[8]={5,4,7,6,1,0,3,2}; int center[8]={6,7,8,11,12,15,16,17}; int q[N]; int path[100]; int f(){ int sum[4]={0}; for(int i=0;i<8;i++) sum[q[center[i]]]++; int s=0; for(int i=1;i<=3;i++){ s=max(sum[i],s); } return 8-s; } void operate(int x){ int t=q[op[x][0]]; for(int i=0;i<6;i++) q[op[x][i]]=q[op[x][i+1]]; q[op[x][6]]=t; } bool dfs(int depth,int max_depth,int last){ if(depth+f()>max_depth) return false; if(f()==0) return true; for(int i=0;i<8;i++){ if(opposite[i]!=last){ operate(i); path[depth]=i; if(dfs(depth+1,max_depth,i)) return true; operate(opposite[i]); } } return false; } int main(){ while(cin>>q[0],q[0]){ for(int i=1;i<N;i++) cin>>q[i]; int depth=0; while(!dfs(0,depth,-1)) depth++; if(!depth) cout<<\"No moves needed\"; else{ for(int i=0;i<depth;i++){ cout<<char(path[i]+'A'); } } cout<<endl<<q[6]<<endl; } }","title":"idea*"},{"location":"algorithms/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/idaxing/#idea","text":"#include<bits/stdc++.h> using namespace std; const int N=24; int op[8][7]={ {0,2,6,11,15,20,22}, {1,3,8,12,17,21,23}, {10,9,8,7,6,5,4}, {19,18,17,16,15,14,13}, {23,21,17,12,8,3,1}, {22,20,15,11,6,2,0}, {13,14,15,16,17,18,19}, {4,5,6,7,8,9,10} }; int opposite[8]={5,4,7,6,1,0,3,2}; int center[8]={6,7,8,11,12,15,16,17}; int q[N]; int path[100]; int f(){ int sum[4]={0}; for(int i=0;i<8;i++) sum[q[center[i]]]++; int s=0; for(int i=1;i<=3;i++){ s=max(sum[i],s); } return 8-s; } void operate(int x){ int t=q[op[x][0]]; for(int i=0;i<6;i++) q[op[x][i]]=q[op[x][i+1]]; q[op[x][6]]=t; } bool dfs(int depth,int max_depth,int last){ if(depth+f()>max_depth) return false; if(f()==0) return true; for(int i=0;i<8;i++){ if(opposite[i]!=last){ operate(i); path[depth]=i; if(dfs(depth+1,max_depth,i)) return true; operate(opposite[i]); } } return false; } int main(){ while(cin>>q[0],q[0]){ for(int i=1;i<N;i++) cin>>q[i]; int depth=0; while(!dfs(0,depth,-1)) depth++; if(!depth) cout<<\"No moves needed\"; else{ for(int i=0;i<depth;i++){ cout<<char(path[i]+'A'); } } cout<<endl<<q[6]<<endl; } }","title":"idea*"},{"location":"algorithms/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/sxgs/","text":"\u53cc\u5411\u5e7f\u641c #include <bits/stdc++.h> #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> #include <ext/pb_ds/hash_policy.hpp> #include <ext/pb_ds/priority_queue.hpp> using namespace std; using namespace __gnu_pbds; using ordered_multiset=tree<int,null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>; typedef long long ll; const int N=6; string a[N],b[N]; int n; int extend(queue<string>& q,unordered_map<string,int>& da,unordered_map<string,int>& db,string a[],string b[]){ int d=da[q.front()]; while(q.size() && da[q.front()]==d){ auto t=q.front(); q.pop(); for(int i=0;i<t.size();i++){ for(int j=0;j<n;j++){ if(t.substr(i,a[j].size())==a[j]){ string state=t.substr(0,i)+b[j]+t.substr(i+a[j].size()); if(db.count(state)) return da[t]+1+db[state]; if(da.count(state)) continue; da[state]=da[t]+1; q.push(state); } } } } return 11; } int bfs(string A,string B){ if(A==B) return 0; queue<string> qa,qb; unordered_map<string,int> da,db; qa.push(A),da[A]=0; qb.push(B),db[B]=0; int step=0; while(qa.size() && qb.size()){ int t; if(qa.size()<=qb.size()){ t=extend(qa,da,db,a,b); } else{ t=extend(qb,db,da,b,a); } if(t<=10) return t; if(++step==10) return -1; } return -1; } void solve(){ string A,B; cin>>A>>B; while(cin>>a[n]>>b[n]) n++; int step=bfs(A,B); if(step==-1) cout<<\"NO ANSWER!\"<<endl; else cout<<step<<endl; } int main(){ int T=1; while(T--){ solve(); } return 0; }","title":"\u53cc\u5411\u5e7f\u641c"},{"location":"algorithms/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/sxgs/#_1","text":"#include <bits/stdc++.h> #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> #include <ext/pb_ds/hash_policy.hpp> #include <ext/pb_ds/priority_queue.hpp> using namespace std; using namespace __gnu_pbds; using ordered_multiset=tree<int,null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>; typedef long long ll; const int N=6; string a[N],b[N]; int n; int extend(queue<string>& q,unordered_map<string,int>& da,unordered_map<string,int>& db,string a[],string b[]){ int d=da[q.front()]; while(q.size() && da[q.front()]==d){ auto t=q.front(); q.pop(); for(int i=0;i<t.size();i++){ for(int j=0;j<n;j++){ if(t.substr(i,a[j].size())==a[j]){ string state=t.substr(0,i)+b[j]+t.substr(i+a[j].size()); if(db.count(state)) return da[t]+1+db[state]; if(da.count(state)) continue; da[state]=da[t]+1; q.push(state); } } } } return 11; } int bfs(string A,string B){ if(A==B) return 0; queue<string> qa,qb; unordered_map<string,int> da,db; qa.push(A),da[A]=0; qb.push(B),db[B]=0; int step=0; while(qa.size() && qb.size()){ int t; if(qa.size()<=qb.size()){ t=extend(qa,da,db,a,b); } else{ t=extend(qb,db,da,b,a); } if(t<=10) return t; if(++step==10) return -1; } return -1; } void solve(){ string A,B; cin>>A>>B; while(cin>>a[n]>>b[n]) n++; int step=bfs(A,B); if(step==-1) cout<<\"NO ANSWER!\"<<endl; else cout<<step<<endl; } int main(){ int T=1; while(T--){ solve(); } return 0; }","title":"\u53cc\u5411\u5e7f\u641c"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/bsgs/","text":"bsgs\u6a21\u677f int bsgs(int a,int b,int p){ if(1%p == b%p) return 0; int k=sqrt(p)+1; unordered_map<int,int> hash; for(int i=0,j=b%p;i<k;i++){ hash[j]=i; j=(ll)j*a%p; } int ak=1%p; for(int i=0;i<k;i++){ ak=(ll)ak*a%p; } for(int i=1,j=ak%p;i<=k;i++){ if(hash.count(j)) return (ll)i*k-hash[j]; j=(ll)j*ak%p; } return -INF; } int exgcd(int a,int b,int &x,int &y){ if(!b){ x=1,y=0; return a; } int d=exgcd(b,a%b,y,x); y-=a/b*x; return d; } int exbsgs(int a,int b,int p){ b=(b%p+p)%p; if(1%p==b%p) return 0; int x,y; int d=exgcd(a,p,x,y); if(d>1){ if(b%d) return -INF; exgcd(a/d,p/d,x,y); return exbsgs(a,(ll)b/d*x%(p/d),p/d)+1; } return bsgs(a,b,p); }","title":"bsgs\u6a21\u677f"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/bsgs/#bsgs","text":"int bsgs(int a,int b,int p){ if(1%p == b%p) return 0; int k=sqrt(p)+1; unordered_map<int,int> hash; for(int i=0,j=b%p;i<k;i++){ hash[j]=i; j=(ll)j*a%p; } int ak=1%p; for(int i=0;i<k;i++){ ak=(ll)ak*a%p; } for(int i=1,j=ak%p;i<=k;i++){ if(hash.count(j)) return (ll)i*k-hash[j]; j=(ll)j*ak%p; } return -INF; } int exgcd(int a,int b,int &x,int &y){ if(!b){ x=1,y=0; return a; } int d=exgcd(b,a%b,y,x); y-=a/b*x; return d; } int exbsgs(int a,int b,int p){ b=(b%p+p)%p; if(1%p==b%p) return 0; int x,y; int d=exgcd(a,p,x,y); if(d>1){ if(b%d) return -INF; exgcd(a/d,p/d,x,y); return exbsgs(a,(ll)b/d*x%(p/d),p/d)+1; } return bsgs(a,b,p); }","title":"bsgs\u6a21\u677f"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/exgcd/","text":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u6c42\u9006\u5143 exgcd(int a,int b,int &x,int &y){ if(b==0){ x=1,y=0; return a; } ll d=exgcd(b,a%b,y,x); y-=a/b*x; return d; }","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u6c42\u9006\u5143"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/exgcd/#_1","text":"exgcd(int a,int b,int &x,int &y){ if(b==0){ x=1,y=0; return a; } ll d=exgcd(b,a%b,y,x); y-=a/b*x; return d; }","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u6c42\u9006\u5143"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/fft/","text":"fft\u6a21\u677f #include<bits/stdc++.h> using namespace std; const int N=300010; const double PI=acos(-1); int n,m; struct Complex{ double x,y; Complex operator+ (const Complex& t) const{ return{x+t.x,y+t.y}; } Complex operator- (const Complex& t) const{ return{x-t.x,y-t.y}; } Complex operator* (const Complex& t) const{ return{x*t.x-y*t.y,x*t.y+y*t.x}; } }a[N],b[N]; int rev[N],bit,tot; void fft(Complex a[],int inv){ for(int i=0;i<tot;i++){ if(i<rev[i]) swap(a[i],a[rev[i]]); } for(int mid=1;mid<tot;mid<<=1){ auto w1=Complex({cos(PI/mid),inv*sin(PI/mid)}); for(int i=0;i<tot;i+=mid*2){ auto wk=Complex({1,0}); for(int j=0;j<mid;j++,wk=wk*w1){ auto x=a[i+j],y=wk*a[i+j+mid]; a[i+j]=x+y,a[i+j+mid]=x-y; } } } } int main(){ cin>>n>>m; for(int i=0;i<=n;i++) cin>>a[i].x; for(int i=0;i<=m;i++) cin>>b[i].x; while((1<<bit)<n+m+1) bit++; tot=1<<bit; for(int i=0;i<tot;i++){ rev[i]=(rev[i>>1]>>1)|((i&1)<<(bit-1)); } fft(a,1); fft(b,1); for(int i=0;i<tot;i++) a[i]=a[i]*b[i]; fft(a,-1); for(int i=0;i<=n+m;i++){ cout<<(int)(a[i].x/tot+0.5)<<\" \"; } return 0; }","title":"fft\u6a21\u677f"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/fft/#fft","text":"#include<bits/stdc++.h> using namespace std; const int N=300010; const double PI=acos(-1); int n,m; struct Complex{ double x,y; Complex operator+ (const Complex& t) const{ return{x+t.x,y+t.y}; } Complex operator- (const Complex& t) const{ return{x-t.x,y-t.y}; } Complex operator* (const Complex& t) const{ return{x*t.x-y*t.y,x*t.y+y*t.x}; } }a[N],b[N]; int rev[N],bit,tot; void fft(Complex a[],int inv){ for(int i=0;i<tot;i++){ if(i<rev[i]) swap(a[i],a[rev[i]]); } for(int mid=1;mid<tot;mid<<=1){ auto w1=Complex({cos(PI/mid),inv*sin(PI/mid)}); for(int i=0;i<tot;i+=mid*2){ auto wk=Complex({1,0}); for(int j=0;j<mid;j++,wk=wk*w1){ auto x=a[i+j],y=wk*a[i+j+mid]; a[i+j]=x+y,a[i+j+mid]=x-y; } } } } int main(){ cin>>n>>m; for(int i=0;i<=n;i++) cin>>a[i].x; for(int i=0;i<=m;i++) cin>>b[i].x; while((1<<bit)<n+m+1) bit++; tot=1<<bit; for(int i=0;i<tot;i++){ rev[i]=(rev[i>>1]>>1)|((i&1)<<(bit-1)); } fft(a,1); fft(b,1); for(int i=0;i<tot;i++) a[i]=a[i]*b[i]; fft(a,-1); for(int i=0;i<=n+m;i++){ cout<<(int)(a[i].x/tot+0.5)<<\" \"; } return 0; }","title":"fft\u6a21\u677f"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/gauss/","text":"\u9ad8\u65af\u6d88\u5143 const double eps=1e-6; int gauss(){ int c,r; for(c=0,r=0;c<n;c++){ int t=r; for(int i=r;i<n;i++){ if(fabs(a[i][c])>fabs(a[t][c])) t=i; } if(fabs(a[t][c])<eps) continue; for(int i=c;i<=n;i++){ swap(a[t][i],a[r][i]); } for(int i=n;i>=c;i--){ a[r][i]/=a[r][c]; } for(int i=r+1;i<n;i++){ if(fabs(a[i][c])>eps){ for(int j=n;j>=c;j--){ a[i][j]-=a[r][j]*a[i][c]; } } } r++; } if(r<n){ for(int i=r;i<n;i++){ if(fabs(a[i][n])>eps) return 2; } return 1; } for(int i=n-1;i>=0;i--){ for(int j=i+1;j<n;j++){ a[i][n]-=a[i][j]*a[j][n]; } } return 0; }","title":"\u9ad8\u65af\u6d88\u5143"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/gauss/#_1","text":"const double eps=1e-6; int gauss(){ int c,r; for(c=0,r=0;c<n;c++){ int t=r; for(int i=r;i<n;i++){ if(fabs(a[i][c])>fabs(a[t][c])) t=i; } if(fabs(a[t][c])<eps) continue; for(int i=c;i<=n;i++){ swap(a[t][i],a[r][i]); } for(int i=n;i>=c;i--){ a[r][i]/=a[r][c]; } for(int i=r+1;i<n;i++){ if(fabs(a[i][c])>eps){ for(int j=n;j>=c;j--){ a[i][j]-=a[r][j]*a[i][c]; } } } r++; } if(r<n){ for(int i=r;i<n;i++){ if(fabs(a[i][n])>eps) return 2; } return 1; } for(int i=n-1;i>=0;i--){ for(int j=i+1;j<n;j++){ a[i][n]-=a[i][j]*a[j][n]; } } return 0; }","title":"\u9ad8\u65af\u6d88\u5143"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/makef/","text":"\u751f\u6210\u51fd\u6570","title":"\u751f\u6210\u51fd\u6570"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/makef/#_1","text":"","title":"\u751f\u6210\u51fd\u6570"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/mu/","text":"\u7ebf\u6027\u6c42\u83ab\u6bd4\u4e4c\u65af\u5e76\u6c42\u524d\u7f00\u548c void init(){ mu[1]=1; for(int i=2;i<N-5;i++){ if(st[i]==0) primes[cnt++]=i,mu[i]=-1; for(int j=0;primes[j]*i<N;j++){ st[primes[j]*i]=true; if(i%primes[j]==0) break; mu[primes[j]*i]=-mu[i]; } } for(int i=1;i<N;i++) sum[i]=sum[i-1]+mu[i]; } int g(int k,int x){ return k/(k/x); } ll f(int a,int b,int k){ a=a/k,b=b/k; ll res=0; int n=min(a,b); for(int l=1,r;l<=n;l=r+1){ r=min(n,min(g(a,l),g(b,l))); res+=(ll)(sum[r]-sum[l-1])*(a/l)*(b/l); } return res; }","title":"\u7ebf\u6027\u6c42\u83ab\u6bd4\u4e4c\u65af\u5e76\u6c42\u524d\u7f00\u548c"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/mu/#_1","text":"void init(){ mu[1]=1; for(int i=2;i<N-5;i++){ if(st[i]==0) primes[cnt++]=i,mu[i]=-1; for(int j=0;primes[j]*i<N;j++){ st[primes[j]*i]=true; if(i%primes[j]==0) break; mu[primes[j]*i]=-mu[i]; } } for(int i=1;i<N;i++) sum[i]=sum[i-1]+mu[i]; } int g(int k,int x){ return k/(k/x); } ll f(int a,int b,int k){ a=a/k,b=b/k; ll res=0; int n=min(a,b); for(int l=1,r;l<=n;l=r+1){ r=min(n,min(g(a,l),g(b,l))); res+=(ll)(sum[r]-sum[l-1])*(a/l)*(b/l); } return res; }","title":"\u7ebf\u6027\u6c42\u83ab\u6bd4\u4e4c\u65af\u5e76\u6c42\u524d\u7f00\u548c"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/oula/","text":"\u7ebf\u6027\u6c42\u6b27\u62c9\u51fd\u6570 int primes[N],cnt; bool st[N]; int phi[N]; phi[1]=1; for(int i=2;i<=n;i++){ if(!st[i]){ primes[cnt++]=i; phi[i]=i-1; } for(int j=0;primes[j]*i<=n;j++){ st[primes[j]*i]=1; if(i%primes[j]==0){ phi[i*primes[j]]=phi[i]*primes[j]; break; } phi[i*primes[j]]=phi[i]*(primes[j]-1); } }","title":"\u7ebf\u6027\u6c42\u6b27\u62c9\u51fd\u6570"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/oula/#_1","text":"int primes[N],cnt; bool st[N]; int phi[N]; phi[1]=1; for(int i=2;i<=n;i++){ if(!st[i]){ primes[cnt++]=i; phi[i]=i-1; } for(int j=0;primes[j]*i<=n;j++){ st[primes[j]*i]=1; if(i%primes[j]==0){ phi[i*primes[j]]=phi[i]*primes[j]; break; } phi[i*primes[j]]=phi[i]*(primes[j]-1); } }","title":"\u7ebf\u6027\u6c42\u6b27\u62c9\u51fd\u6570"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/polya/","text":"polya\u5b9a\u7406 typedef long long ll; int gcd(int a,int b){ return b?gcd(b,a%b):a; } ll qsm(ll a,ll b){ ll res=1; while(b){ if(b&1) res=(res*a); a=(a*a); b>>=1; } return res; } int main(){ int m,n; while(cin>>m>>n, m||n){ ll res=0; for(int i=0;i<n;i++){ res+=qsm(m,gcd(n,i)); } if(n%2){ res+=n*qsm(m,(n+1)/2); } else{ res+=n/2*(qsm(m,n/2+1)+qsm(m,n/2)); } cout<<res/(2*n)<<endl; } return 0; }","title":"polya\u5b9a\u7406"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/polya/#polya","text":"typedef long long ll; int gcd(int a,int b){ return b?gcd(b,a%b):a; } ll qsm(ll a,ll b){ ll res=1; while(b){ if(b&1) res=(res*a); a=(a*a); b>>=1; } return res; } int main(){ int m,n; while(cin>>m>>n, m||n){ ll res=0; for(int i=0;i<n;i++){ res+=qsm(m,gcd(n,i)); } if(n%2){ res+=n*qsm(m,(n+1)/2); } else{ res+=n/2*(qsm(m,n/2+1)+qsm(m,n/2)); } cout<<res/(2*n)<<endl; } return 0; }","title":"polya\u5b9a\u7406"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/prime/","text":"\u7ebf\u6027\u7b5b int primes[N],cnt; bool sg[N]; for(int i=2;i<=n;i++){ if(!sg[i]) primes[cnt++]=i; for(int j=0;primes[j]*i<=n;j++){ sg[primes[j]*i]=true; } }","title":"\u7ebf\u6027\u7b5b"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/prime/#_1","text":"int primes[N],cnt; bool sg[N]; for(int i=2;i<=n;i++){ if(!sg[i]) primes[cnt++]=i; for(int j=0;primes[j]*i<=n;j++){ sg[primes[j]*i]=true; } }","title":"\u7ebf\u6027\u7b5b"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/stl1/","text":"\u7b2c\u4e00\u7c7b\u65af\u7279\u6797\u6570 f[0][0]=1; for(int i=1;i<=n;i++){ for(int j=1;j<=m;j++){ f[i][j]=(f[i-1][j-1]+(ll)(i-1)*f[i-1][j])%mod; } }","title":"\u7b2c\u4e00\u7c7b\u65af\u7279\u6797\u6570"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/stl1/#_1","text":"f[0][0]=1; for(int i=1;i<=n;i++){ for(int j=1;j<=m;j++){ f[i][j]=(f[i-1][j-1]+(ll)(i-1)*f[i-1][j])%mod; } }","title":"\u7b2c\u4e00\u7c7b\u65af\u7279\u6797\u6570"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/stl2/","text":"\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 f[0][0]=1; for(int i=1;i<=n;i++){ for(int j=1;j<=m;j++){ f[i][j]=(f[i-1][j-1]+(ll)(j)*f[i-1][j])%mod; } }","title":"\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/stl2/#_1","text":"f[0][0]=1; for(int i=1;i<=n;i++){ for(int j=1;j<=m;j++){ f[i][j]=(f[i-1][j-1]+(ll)(j)*f[i-1][j])%mod; } }","title":"\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/xxj/","text":"\u7ebf\u6027\u57fa //\u5df2\u77e5\u7ebf\u6027\u57fa\u6c42\u6700\u5927\u503c int findmax(ll *p, int k) { sort(p+1,p+k+1,greater<int>()); ll v=0; for(int i=1;i<=k;i++) v=max(v,v^p[i]); return v; } //\u6c42\u7ebf\u6027\u57fa int k=0; for(int i=62;i>=0;i--){ for(int j=k;j<n;j++){ if(a[j]>>i&1){ swap(a[j],a[k]); break; } } if(!(a[k]>>i&1)) continue; for(int j=0;j<n;j++){ if(j!=k && (a[j]>>i&1)) a[j]^=a[k]; } k++; if(k==n) break; }","title":"\u7ebf\u6027\u57fa"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/xxj/#_1","text":"//\u5df2\u77e5\u7ebf\u6027\u57fa\u6c42\u6700\u5927\u503c int findmax(ll *p, int k) { sort(p+1,p+k+1,greater<int>()); ll v=0; for(int i=1;i<=k;i++) v=max(v,v^p[i]); return v; } //\u6c42\u7ebf\u6027\u57fa int k=0; for(int i=62;i>=0;i--){ for(int j=k;j<n;j++){ if(a[j]>>i&1){ swap(a[j],a[k]); break; } } if(!(a[k]>>i&1)) continue; for(int j=0;j<n;j++){ if(j!=k && (a[j]>>i&1)) a[j]^=a[k]; } k++; if(k==n) break; }","title":"\u7ebf\u6027\u57fa"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/ysf/","text":"\u7ea6\u745f\u592b\u95ee\u9898 #include <bits/stdc++.h> #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> #include <ext/pb_ds/hash_policy.hpp> #include <ext/pb_ds/priority_queue.hpp> using namespace std; using namespace __gnu_pbds; using ordered_multiset=tree<int,null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>; typedef long long ll; void solve(){ ll n,m,k; cin>>n>>m>>k; if(m<=k){ ll f; f=k%(n-m+1); if(f==0) f=n-m+1; for(ll i=2;i<=m;i++){ f=(f+k)%(n-m+i); } cout<<f; } else{ if(k==1) cout<<m,return; ll a=n-m+1,b=1; ll f=k%a,x=0; if(f==0) f=a; while(b+x<=m){ a+=x,b+=x,f+=k*x; f%=a; if(f==0) f=a; x=(a-f)/(k-1)+1; } f+=(m-b)*k; f%=n; if(f==0) f=n; cout<<f; } } int main(){ int T; cin>>T; for(int _=1;_<=T;_++){ cout<<\"Case #\"<<_<<\": \"; solve(); cout<<endl; } return 0; }","title":"\u7ea6\u745f\u592b\u95ee\u9898"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/ysf/#_1","text":"#include <bits/stdc++.h> #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> #include <ext/pb_ds/hash_policy.hpp> #include <ext/pb_ds/priority_queue.hpp> using namespace std; using namespace __gnu_pbds; using ordered_multiset=tree<int,null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>; typedef long long ll; void solve(){ ll n,m,k; cin>>n>>m>>k; if(m<=k){ ll f; f=k%(n-m+1); if(f==0) f=n-m+1; for(ll i=2;i<=m;i++){ f=(f+k)%(n-m+i); } cout<<f; } else{ if(k==1) cout<<m,return; ll a=n-m+1,b=1; ll f=k%a,x=0; if(f==0) f=a; while(b+x<=m){ a+=x,b+=x,f+=k*x; f%=a; if(f==0) f=a; x=(a-f)/(k-1)+1; } f+=(m-b)*k; f%=n; if(f==0) f=n; cout<<f; } } int main(){ int T; cin>>T; for(int _=1;_<=T;_++){ cout<<\"Case #\"<<_<<\": \"; solve(); cout<<endl; } return 0; }","title":"\u7ea6\u745f\u592b\u95ee\u9898"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/zzyz/","text":"\u627e\u6240\u6709\u6570\u6700\u5c0f\u8d28\u56e0\u5b50 \u8d28\u6570\u4e3a0 int primes[N],cnt=0; int st[N]; void init(){ st[1]=1; for(int i=2;i<=N-5;i++){ if(!st[i]){ primes[cnt++]=i; } for(int j=0;primes[j]*i<=N-5;j++){ st[primes[j]*i]=primes[j]; if(i%primes[j]==0){ break; } } } }","title":"\u627e\u6240\u6709\u6570\u6700\u5c0f\u8d28\u56e0\u5b50"},{"location":"algorithms/%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%9D%BF/zzyz/#_1","text":"\u8d28\u6570\u4e3a0 int primes[N],cnt=0; int st[N]; void init(){ st[1]=1; for(int i=2;i<=N-5;i++){ if(!st[i]){ primes[cnt++]=i; } for(int j=0;primes[j]*i<=N-5;j++){ st[primes[j]*i]=primes[j]; if(i%primes[j]==0){ break; } } } }","title":"\u627e\u6240\u6709\u6570\u6700\u5c0f\u8d28\u56e0\u5b50"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/banpingmian/","text":"\u534a\u5e73\u9762\u4ea4 #include <bits/stdc++.h> using namespace std; #define x first #define y second typedef pair<double,double> PDD; const int N=510; const double eps=1e-8; int cnt; struct Line{ PDD st,ed; }line[N]; int q[N]; PDD pg[N],ans[N]; PDD operator- (PDD a,PDD b){ return {a.x-b.x,a.y-b.y}; } int sign(double x){ if(fabs(x)<eps) return 0; if(x<0) return -1; return 1; } int dcmp(double x,double y){ if(fabs(x-y)<eps) return 0; if(x<y) return -1; return 1; } double get_angle(const Line &a){ return atan2(a.ed.y-a.st.y,a.ed.x-a.st.x); } double cross(PDD a,PDD b){ return a.x*b.y-a.y*b.x; } double area(PDD a,PDD b,PDD c){ return cross(b-a,c-a); } bool cmp(const Line& a,const Line& b){ double A=get_angle(a),B=get_angle(b); if(!dcmp(A,B)) return area(a.st,a.ed,b.ed)<0; return A<B; } PDD get_line_intersection(PDD p,PDD v,PDD q,PDD w){ auto u=p-q; double t=cross(w,u)/cross(v,w); return {p.x+v.x*t,p.y+v.y*t}; } PDD get_line_intersection(Line a,Line b){ return get_line_intersection(a.st,a.ed-a.st,b.st,b.ed-b.st); } bool on_right(Line &a,Line &b,Line &c){ auto o=get_line_intersection(b,c); return sign(area(a.st,a.ed,o))<=0; } double half_plane_intersection(){ sort(line,line+cnt,cmp); int hh=0,tt=-1; for(int i=0;i<cnt;i++){ if(i && !dcmp(get_angle(line[i]),get_angle(line[i-1]))) continue; while(hh+1<=tt && on_right(line[i],line[q[tt-1]],line[q[tt]])) tt--; while(hh+1<=tt && on_right(line[i],line[q[hh]],line[q[hh+1]])) hh++; q[++tt]=i; } while(hh+1<=tt && on_right(line[q[hh]],line[q[tt-1]],line[q[tt]])) tt--; while(hh+1<=tt && on_right(line[q[tt]],line[q[hh]],line[q[hh+1]])) hh++; q[++tt]=q[hh]; int k=0; for(int i=hh;i<tt;i++){ ans[k++]=get_line_intersection(line[q[i]],line[q[i+1]]); } double res=0; for(int i=1;i+1<k;i++){ res+=area(ans[0],ans[i],ans[i+1]); } return res/2; } int main(){ int n,m; cin>>n; while(n--){ cin>>m; for(int i=0;i<m;i++) cin>>pg[i].x>>pg[i].y; for(int i=0;i<m;i++){ line[cnt++]={pg[i],pg[(i+1)%m]}; } } double res=half_plane_intersection(); printf(\"%.3lf\\n\",res); return 0; }","title":"\u534a\u5e73\u9762\u4ea4"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/banpingmian/#_1","text":"#include <bits/stdc++.h> using namespace std; #define x first #define y second typedef pair<double,double> PDD; const int N=510; const double eps=1e-8; int cnt; struct Line{ PDD st,ed; }line[N]; int q[N]; PDD pg[N],ans[N]; PDD operator- (PDD a,PDD b){ return {a.x-b.x,a.y-b.y}; } int sign(double x){ if(fabs(x)<eps) return 0; if(x<0) return -1; return 1; } int dcmp(double x,double y){ if(fabs(x-y)<eps) return 0; if(x<y) return -1; return 1; } double get_angle(const Line &a){ return atan2(a.ed.y-a.st.y,a.ed.x-a.st.x); } double cross(PDD a,PDD b){ return a.x*b.y-a.y*b.x; } double area(PDD a,PDD b,PDD c){ return cross(b-a,c-a); } bool cmp(const Line& a,const Line& b){ double A=get_angle(a),B=get_angle(b); if(!dcmp(A,B)) return area(a.st,a.ed,b.ed)<0; return A<B; } PDD get_line_intersection(PDD p,PDD v,PDD q,PDD w){ auto u=p-q; double t=cross(w,u)/cross(v,w); return {p.x+v.x*t,p.y+v.y*t}; } PDD get_line_intersection(Line a,Line b){ return get_line_intersection(a.st,a.ed-a.st,b.st,b.ed-b.st); } bool on_right(Line &a,Line &b,Line &c){ auto o=get_line_intersection(b,c); return sign(area(a.st,a.ed,o))<=0; } double half_plane_intersection(){ sort(line,line+cnt,cmp); int hh=0,tt=-1; for(int i=0;i<cnt;i++){ if(i && !dcmp(get_angle(line[i]),get_angle(line[i-1]))) continue; while(hh+1<=tt && on_right(line[i],line[q[tt-1]],line[q[tt]])) tt--; while(hh+1<=tt && on_right(line[i],line[q[hh]],line[q[hh+1]])) hh++; q[++tt]=i; } while(hh+1<=tt && on_right(line[q[hh]],line[q[tt-1]],line[q[tt]])) tt--; while(hh+1<=tt && on_right(line[q[tt]],line[q[hh]],line[q[hh+1]])) hh++; q[++tt]=q[hh]; int k=0; for(int i=hh;i<tt;i++){ ans[k++]=get_line_intersection(line[q[i]],line[q[i+1]]); } double res=0; for(int i=1;i+1<k;i++){ res+=area(ans[0],ans[i],ans[i+1]); } return res/2; } int main(){ int n,m; cin>>n; while(n--){ cin>>m; for(int i=0;i<m;i++) cin>>pg[i].x>>pg[i].y; for(int i=0;i<m;i++){ line[cnt++]={pg[i],pg[(i+1)%m]}; } } double res=half_plane_intersection(); printf(\"%.3lf\\n\",res); return 0; }","title":"\u534a\u5e73\u9762\u4ea4"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/basic/","text":"\u8ba1\u7b97\u51e0\u4f55\u57fa\u672c\u64cd\u4f5c #define x first #define y second typedef pair<double,double> PDD; const double eps=1e-8; const double pi=acos(-1); int sign(double x){ if(fabs(x)<eps){ return 0; } if(x<0) return -1; else return 1; } int dcmp(double x,double y){ if(fabs(x-y)<eps) return 0; if(x<y) return -1; else return 1; } PDD operator+ (PDD a,PDD b){ return {a.x+b.x,a.y+b.y}; } PDD operator- (PDD a,PDD b){ return {a.x-b.x,a.y-b.y}; } PDD operator* (PDD a,double t){ return {a.x*t,a.y*t}; } PDD operator/ (PDD a,double t){ return {a.x/t,a.y/t}; } double operator*(PDD a,PDD b){ return a.x*b.y-a.y*b.x; } double operator& (PDD a,PDD b){ return a.x*b.x+a.y*b.y; } double get_angle(PDD a,PDD b){//\u6c42\u89d2\u5ea6 return acos((a&b)/get_len(a)/get_len(b)); } double area(PDD a,PDD b,PDD c){//\u6c42\u9762\u79ef return (b-a)*(c-a); } double get_len(PDD a){//\u6c42\u957f\u5ea6 return sqrt(a&a); } double get_dist(PDD a,PDD b){//\u6c42\u8ddd\u79bb return get_len(b-a); } double project(PDD a,PDD b,PDD c){//\u8ba1\u7b97\u70b9c\u5230ab\u7684\u6295\u5f71\u957f\u5ea6 return ((c-a)&(b-a))/get_len(b-a); } PDD rotate(PDD a,double b){//\u65cb\u8f6c return {a.x*cos(b)+a.y*sin(b),-a.x*sin(b)+a.y*cos(b)}; } PDD norm(PDD a){//\u5355\u4f4d\u7ebf\u6bb5 return a/get_len(a); } PDD get_line_intersection(PDD p,PDD v,PDD q,PDD w){//\u4e24\u7ebf\u7126\u70b9 auto u=p-q; auto t=w*u/(v*w); return p+v*t; } double distance_to_line(PDD p,PDD a,PDD b){//\u70b9\u5230\u76f4\u7ebf\u8ddd\u79bb PDD v1=b-a,v2=p-a; return fabs((v1*v2)/get_len(v1)); } double distance_to_segment(PDD p,PDD a,PDD b){//\u70b9\u5230\u7ebf\u6bb5\u8ddd\u79bb if(a==b){ return get_len(p-a); } PDD v1=b-a,v2=p-a,v3=p-b; if(sign(v1&v2)<0) return get_len(v2); if(sign(v1&v3)<0) return get_len(v3); return distance_to_line(p,a,b); } bool on_segment(PDD p,PDD a,PDD b){//\u5224\u65ad\u70b9\u662f\u4e0d\u662f\u5728\u7ebf\u4e0a return !sign((p-a)*(p-b)) && sign((p-a)&(p-b))<=0; } double get_circle_line_intersection(PDD a,PDD b,PDD &pa,PDD &pb){//\u6c42\u76f4\u7ebf\u548c\u5706\u7684\u4ea4\u70b9 auto e=get_line_intersection(a,b-a,r,rotate(b-a,pi/2)); auto mind=get_dist(r,e); if(!on_segment(e,a,b)) mind=min(get_dist(r,a),get_dist(r,b)); if(dcmp(R,mind)<=0) return mind; auto len=sqrt(R*R-get_dist(r,e)*get_dist(r,e)); pa=e+norm(a-b)*len; pb=e+norm(b-a)*len; return mind; } double get_sector(PDD a,PDD b){//\u6c42\u6247\u5f62\u9762\u79ef auto angle=acos((a&b)/get_len(a)/get_len(b)); if(sign(a*b)<0) angle=-angle; return R*R*angle/2; }","title":"\u8ba1\u7b97\u51e0\u4f55\u57fa\u672c\u64cd\u4f5c"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/basic/#_1","text":"#define x first #define y second typedef pair<double,double> PDD; const double eps=1e-8; const double pi=acos(-1); int sign(double x){ if(fabs(x)<eps){ return 0; } if(x<0) return -1; else return 1; } int dcmp(double x,double y){ if(fabs(x-y)<eps) return 0; if(x<y) return -1; else return 1; } PDD operator+ (PDD a,PDD b){ return {a.x+b.x,a.y+b.y}; } PDD operator- (PDD a,PDD b){ return {a.x-b.x,a.y-b.y}; } PDD operator* (PDD a,double t){ return {a.x*t,a.y*t}; } PDD operator/ (PDD a,double t){ return {a.x/t,a.y/t}; } double operator*(PDD a,PDD b){ return a.x*b.y-a.y*b.x; } double operator& (PDD a,PDD b){ return a.x*b.x+a.y*b.y; } double get_angle(PDD a,PDD b){//\u6c42\u89d2\u5ea6 return acos((a&b)/get_len(a)/get_len(b)); } double area(PDD a,PDD b,PDD c){//\u6c42\u9762\u79ef return (b-a)*(c-a); } double get_len(PDD a){//\u6c42\u957f\u5ea6 return sqrt(a&a); } double get_dist(PDD a,PDD b){//\u6c42\u8ddd\u79bb return get_len(b-a); } double project(PDD a,PDD b,PDD c){//\u8ba1\u7b97\u70b9c\u5230ab\u7684\u6295\u5f71\u957f\u5ea6 return ((c-a)&(b-a))/get_len(b-a); } PDD rotate(PDD a,double b){//\u65cb\u8f6c return {a.x*cos(b)+a.y*sin(b),-a.x*sin(b)+a.y*cos(b)}; } PDD norm(PDD a){//\u5355\u4f4d\u7ebf\u6bb5 return a/get_len(a); } PDD get_line_intersection(PDD p,PDD v,PDD q,PDD w){//\u4e24\u7ebf\u7126\u70b9 auto u=p-q; auto t=w*u/(v*w); return p+v*t; } double distance_to_line(PDD p,PDD a,PDD b){//\u70b9\u5230\u76f4\u7ebf\u8ddd\u79bb PDD v1=b-a,v2=p-a; return fabs((v1*v2)/get_len(v1)); } double distance_to_segment(PDD p,PDD a,PDD b){//\u70b9\u5230\u7ebf\u6bb5\u8ddd\u79bb if(a==b){ return get_len(p-a); } PDD v1=b-a,v2=p-a,v3=p-b; if(sign(v1&v2)<0) return get_len(v2); if(sign(v1&v3)<0) return get_len(v3); return distance_to_line(p,a,b); } bool on_segment(PDD p,PDD a,PDD b){//\u5224\u65ad\u70b9\u662f\u4e0d\u662f\u5728\u7ebf\u4e0a return !sign((p-a)*(p-b)) && sign((p-a)&(p-b))<=0; } double get_circle_line_intersection(PDD a,PDD b,PDD &pa,PDD &pb){//\u6c42\u76f4\u7ebf\u548c\u5706\u7684\u4ea4\u70b9 auto e=get_line_intersection(a,b-a,r,rotate(b-a,pi/2)); auto mind=get_dist(r,e); if(!on_segment(e,a,b)) mind=min(get_dist(r,a),get_dist(r,b)); if(dcmp(R,mind)<=0) return mind; auto len=sqrt(R*R-get_dist(r,e)*get_dist(r,e)); pa=e+norm(a-b)*len; pb=e+norm(b-a)*len; return mind; } double get_sector(PDD a,PDD b){//\u6c42\u6247\u5f62\u9762\u79ef auto angle=acos((a&b)/get_len(a)/get_len(b)); if(sign(a*b)<0) angle=-angle; return R*R*angle/2; }","title":"\u8ba1\u7b97\u51e0\u4f55\u57fa\u672c\u64cd\u4f5c"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/erweitubao/","text":"\u4e8c\u7ef4\u51f8\u5305\u6a21\u677f #include <bits/stdc++.h> using namespace std; #define x first #define y second typedef pair<double,double> PDD; const int N=10010; int n; PDD q[N]; int stk[N]; bool used[N]; PDD operator -(PDD a,PDD b){ return {a.x-b.x,a.y-b.y}; } double get_dist(PDD a,PDD b){ double dx=a.x-b.x; double dy=a.y-b.y; return sqrt(dx*dx+dy*dy); } double cross(PDD a,PDD b){ return a.x*b.y-a.y*b.x; } double area(PDD a,PDD b,PDD c){ return cross(b-a,c-a); } double andrew(){ sort(q,q+n); int top=0; for(int i=0;i<n;i++){ while(top>=2 && area(q[stk[top-1]],q[stk[top]],q[i])<=0){ if(area(q[stk[top-1]],q[stk[top]],q[i])<0){ used[stk[top--]]=false; } else top--; } stk[++top]=i; used[i]=true; } used[0]=false; for(int i=n-1;i>=0;i--){ if(used[i]) continue; while(top>=2 && area(q[stk[top-1]],q[stk[top]],q[i])<=0){ top--; } stk[++top]=i; } double res=0; for(int i=2;i<=top;i++) res+=get_dist(q[stk[i-1]],q[stk[i]]); return res; } int main(){ cin>>n; for(int i=0;i<n;i++){ cin>>q[i].x>>q[i].y; } double res=andrew(); printf(\"%.2lf\\n\",res); return 0; }","title":"\u4e8c\u7ef4\u51f8\u5305\u6a21\u677f"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/erweitubao/#_1","text":"#include <bits/stdc++.h> using namespace std; #define x first #define y second typedef pair<double,double> PDD; const int N=10010; int n; PDD q[N]; int stk[N]; bool used[N]; PDD operator -(PDD a,PDD b){ return {a.x-b.x,a.y-b.y}; } double get_dist(PDD a,PDD b){ double dx=a.x-b.x; double dy=a.y-b.y; return sqrt(dx*dx+dy*dy); } double cross(PDD a,PDD b){ return a.x*b.y-a.y*b.x; } double area(PDD a,PDD b,PDD c){ return cross(b-a,c-a); } double andrew(){ sort(q,q+n); int top=0; for(int i=0;i<n;i++){ while(top>=2 && area(q[stk[top-1]],q[stk[top]],q[i])<=0){ if(area(q[stk[top-1]],q[stk[top]],q[i])<0){ used[stk[top--]]=false; } else top--; } stk[++top]=i; used[i]=true; } used[0]=false; for(int i=n-1;i>=0;i--){ if(used[i]) continue; while(top>=2 && area(q[stk[top-1]],q[stk[top]],q[i])<=0){ top--; } stk[++top]=i; } double res=0; for(int i=2;i<=top;i++) res+=get_dist(q[stk[i-1]],q[stk[i]]); return res; } int main(){ cin>>n; for(int i=0;i<n;i++){ cin>>q[i].x>>q[i].y; } double res=andrew(); printf(\"%.2lf\\n\",res); return 0; }","title":"\u4e8c\u7ef4\u51f8\u5305\u6a21\u677f"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/sjpf/","text":"\u4e09\u89d2\u5256\u5206 #include<bits/stdc++.h> #define x first #define y second using namespace std; typedef pair<double,double> PDD; const double eps=1e-8; const double pi=acos(-1); const int N=55; double R; int n; PDD q[N],r; int sign(double x){ if(fabs(x)<eps){ return 0; } if(x<0) return -1; else return 1; } int dcmp(double x,double y){ if(fabs(x-y)<eps) return 0; if(x<y) return -1; else return 1; } PDD operator+ (PDD a,PDD b){ return {a.x+b.x,a.y+b.y}; } PDD operator- (PDD a,PDD b){ return {a.x-b.x,a.y-b.y}; } PDD operator* (PDD a,double t){ return {a.x*t,a.y*t}; } PDD operator/ (PDD a,double t){ return {a.x/t,a.y/t}; } double operator*(PDD a,PDD b){ return a.x*b.y-a.y*b.x; } double operator& (PDD a,PDD b){ return a.x*b.x+a.y*b.y; } double area(PDD a,PDD b,PDD c){ return (b-a)*(c-a); } double get_len(PDD a){ return sqrt(a&a); } double get_dist(PDD a,PDD b){ return get_len(b-a); } double project(PDD a,PDD b,PDD c){ return ((c-a)&(b-a))/get_len(b-a); } PDD rotate(PDD a,double b){ return {a.x*cos(b)+a.y*sin(b),-a.x*sin(b)+a.y*cos(b)}; } PDD norm(PDD a){ return a/get_len(a); } PDD get_line_intersection(PDD p,PDD v,PDD q,PDD w){ auto u=p-q; auto t=w*u/(v*w); return p+v*t; } bool on_segment(PDD p,PDD a,PDD b){ return !sign((p-a)*(p-b)) && sign((p-a)&(p-b))<=0; } double get_circle_line_intersection(PDD a,PDD b,PDD &pa,PDD &pb){ auto e=get_line_intersection(a,b-a,r,rotate(b-a,pi/2)); auto mind=get_dist(r,e); if(!on_segment(e,a,b)) mind=min(get_dist(r,a),get_dist(r,b)); if(dcmp(R,mind)<=0) return mind; auto len=sqrt(R*R-get_dist(r,e)*get_dist(r,e)); pa=e+norm(a-b)*len; pb=e+norm(b-a)*len; return mind; } double get_sector(PDD a,PDD b){ auto angle=acos((a&b)/get_len(a)/get_len(b)); if(sign(a*b)<0) angle=-angle; return R*R*angle/2; } double get_circle_triangle_ares(PDD a,PDD b){ auto da=get_dist(r,a),db=get_dist(r,b); if(dcmp(R,da)>=0 && dcmp(R,db)>=0) return a*b/2; if(!sign(a*b)) return 0; PDD pa,pb; auto mind=get_circle_line_intersection(a,b,pa,pb); if(dcmp(R,mind)<=0) return get_sector(a,b); if(dcmp(R,da)>=0) return get_sector(pb,b)+a*pb/2; if(dcmp(R,db)>=0) return get_sector(a,pa)+pa*b/2; return get_sector(a,pa)+pa*pb/2+get_sector(pb,b); } double work(){ double res=0; for(int i=0;i<n;i++){ res+=get_circle_triangle_ares(q[i],q[(i+1)%n]); } return fabs(res); } int main(){ while(cin>>R>>n){ for(int i=0;i<n;i++){ cin>>q[i].x>>q[i].y; } printf(\"%.2lf\\n\",work()); } return 0; }","title":"\u4e09\u89d2\u5256\u5206"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/sjpf/#_1","text":"#include<bits/stdc++.h> #define x first #define y second using namespace std; typedef pair<double,double> PDD; const double eps=1e-8; const double pi=acos(-1); const int N=55; double R; int n; PDD q[N],r; int sign(double x){ if(fabs(x)<eps){ return 0; } if(x<0) return -1; else return 1; } int dcmp(double x,double y){ if(fabs(x-y)<eps) return 0; if(x<y) return -1; else return 1; } PDD operator+ (PDD a,PDD b){ return {a.x+b.x,a.y+b.y}; } PDD operator- (PDD a,PDD b){ return {a.x-b.x,a.y-b.y}; } PDD operator* (PDD a,double t){ return {a.x*t,a.y*t}; } PDD operator/ (PDD a,double t){ return {a.x/t,a.y/t}; } double operator*(PDD a,PDD b){ return a.x*b.y-a.y*b.x; } double operator& (PDD a,PDD b){ return a.x*b.x+a.y*b.y; } double area(PDD a,PDD b,PDD c){ return (b-a)*(c-a); } double get_len(PDD a){ return sqrt(a&a); } double get_dist(PDD a,PDD b){ return get_len(b-a); } double project(PDD a,PDD b,PDD c){ return ((c-a)&(b-a))/get_len(b-a); } PDD rotate(PDD a,double b){ return {a.x*cos(b)+a.y*sin(b),-a.x*sin(b)+a.y*cos(b)}; } PDD norm(PDD a){ return a/get_len(a); } PDD get_line_intersection(PDD p,PDD v,PDD q,PDD w){ auto u=p-q; auto t=w*u/(v*w); return p+v*t; } bool on_segment(PDD p,PDD a,PDD b){ return !sign((p-a)*(p-b)) && sign((p-a)&(p-b))<=0; } double get_circle_line_intersection(PDD a,PDD b,PDD &pa,PDD &pb){ auto e=get_line_intersection(a,b-a,r,rotate(b-a,pi/2)); auto mind=get_dist(r,e); if(!on_segment(e,a,b)) mind=min(get_dist(r,a),get_dist(r,b)); if(dcmp(R,mind)<=0) return mind; auto len=sqrt(R*R-get_dist(r,e)*get_dist(r,e)); pa=e+norm(a-b)*len; pb=e+norm(b-a)*len; return mind; } double get_sector(PDD a,PDD b){ auto angle=acos((a&b)/get_len(a)/get_len(b)); if(sign(a*b)<0) angle=-angle; return R*R*angle/2; } double get_circle_triangle_ares(PDD a,PDD b){ auto da=get_dist(r,a),db=get_dist(r,b); if(dcmp(R,da)>=0 && dcmp(R,db)>=0) return a*b/2; if(!sign(a*b)) return 0; PDD pa,pb; auto mind=get_circle_line_intersection(a,b,pa,pb); if(dcmp(R,mind)<=0) return get_sector(a,b); if(dcmp(R,da)>=0) return get_sector(pb,b)+a*pb/2; if(dcmp(R,db)>=0) return get_sector(a,pa)+pa*b/2; return get_sector(a,pa)+pa*pb/2+get_sector(pb,b); } double work(){ double res=0; for(int i=0;i<n;i++){ res+=get_circle_triangle_ares(q[i],q[(i+1)%n]); } return fabs(res); } int main(){ while(cin>>R>>n){ for(int i=0;i<n;i++){ cin>>q[i].x>>q[i].y; } printf(\"%.2lf\\n\",work()); } return 0; }","title":"\u4e09\u89d2\u5256\u5206"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/swtb/","text":"\u4e09\u7ef4\u51f8\u5305 \u6c42\u70b9\u9635\u51f8\u5305\u7684\u6700\u5c0f\u8868\u9762\u79ef #include<bits/stdc++.h> using namespace std; const int N=210; const double eps=1e-10; int n,m; bool g[N][N]; double rand_eps(){ return ((double)rand()/RAND_MAX-0.5)*eps; } struct Point{ double x,y,z; void shake(){ x+=rand_eps(),y+=rand_eps(),z+=rand_eps(); } Point operator- (Point t){ return {x-t.x,y-t.y,z-t.z}; } double operator& (Point t){ return x*t.x+y*t.y+z*t.z; } Point operator* (Point t){ return {y*t.z-t.y*z,z*t.x-x*t.z,x*t.y-y*t.x}; } double len(){ return sqrt(x*x+y*y+z*z); } }q[N]; struct Plane{ int v[3]; Point norm(){ return (q[v[1]]-q[v[0]])*(q[v[2]]-q[v[0]]); } double area(){ return norm().len()/2; } bool above(Point a){ return ((a-q[v[0]])&norm())>=0; } }plane[N],np[N]; void get_convex_3d(){ plane[m++]={0,1,2}; plane[m++]={2,1,0}; for(int i=3;i<n;i++){ int cnt=0; for(int j=0;j<m;j++){ bool t=plane[j].above(q[i]); if(!t) np[cnt++]=plane[j]; for(int k=0;k<3;k++){ g[plane[j].v[k]][plane[j].v[(k+1)%3]]=t; } } for(int j=0;j<m;j++){ for(int k=0;k<3;k++){ int a=plane[j].v[k],b=plane[j].v[(k+1)%3]; if(g[a][b] && !g[b][a]){ np[cnt++]={a,b,i}; } } } m=cnt; for(int j=0;j<m;j++){ plane[j]=np[j]; } } } int main(){ cin>>n; for(int i=0;i<n;i++){ cin>>q[i].x>>q[i].y>>q[i].z; q[i].shake(); } get_convex_3d(); double res=0; for(int i=0;i<m;i++){ res+=plane[i].area(); } printf(\"%.6lf\",res); return 0; }","title":"\u4e09\u7ef4\u51f8\u5305"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/swtb/#_1","text":"\u6c42\u70b9\u9635\u51f8\u5305\u7684\u6700\u5c0f\u8868\u9762\u79ef #include<bits/stdc++.h> using namespace std; const int N=210; const double eps=1e-10; int n,m; bool g[N][N]; double rand_eps(){ return ((double)rand()/RAND_MAX-0.5)*eps; } struct Point{ double x,y,z; void shake(){ x+=rand_eps(),y+=rand_eps(),z+=rand_eps(); } Point operator- (Point t){ return {x-t.x,y-t.y,z-t.z}; } double operator& (Point t){ return x*t.x+y*t.y+z*t.z; } Point operator* (Point t){ return {y*t.z-t.y*z,z*t.x-x*t.z,x*t.y-y*t.x}; } double len(){ return sqrt(x*x+y*y+z*z); } }q[N]; struct Plane{ int v[3]; Point norm(){ return (q[v[1]]-q[v[0]])*(q[v[2]]-q[v[0]]); } double area(){ return norm().len()/2; } bool above(Point a){ return ((a-q[v[0]])&norm())>=0; } }plane[N],np[N]; void get_convex_3d(){ plane[m++]={0,1,2}; plane[m++]={2,1,0}; for(int i=3;i<n;i++){ int cnt=0; for(int j=0;j<m;j++){ bool t=plane[j].above(q[i]); if(!t) np[cnt++]=plane[j]; for(int k=0;k<3;k++){ g[plane[j].v[k]][plane[j].v[(k+1)%3]]=t; } } for(int j=0;j<m;j++){ for(int k=0;k<3;k++){ int a=plane[j].v[k],b=plane[j].v[(k+1)%3]; if(g[a][b] && !g[b][a]){ np[cnt++]={a,b,i}; } } } m=cnt; for(int j=0;j<m;j++){ plane[j]=np[j]; } } } int main(){ cin>>n; for(int i=0;i<n;i++){ cin>>q[i].x>>q[i].y>>q[i].z; q[i].shake(); } get_convex_3d(); double res=0; for(int i=0;i<m;i++){ res+=plane[i].area(); } printf(\"%.6lf\",res); return 0; }","title":"\u4e09\u7ef4\u51f8\u5305"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/xzkk/","text":"\u65cb\u8f6c\u5361\u58f3 #include<bits/stdc++.h> using namespace std; #define x first #define y second typedef pair<int,int> PII; const int N=50010; int n; PII q[N]; int stk[N],top; bool used[N]; PII operator- (PII a,PII b){ return {a.x-b.x,a.y-b.y}; } int operator* (PII a,PII b){ return a.x*b.y-a.y*b.x; } int area(PII a,PII b,PII c){ return (b-a)*(c-a); } int get_dist(PII a,PII b){ int dx=a.x-b.x; int dy=a.y-b.y; return dx*dx+dy*dy; } void get_convex(){ sort(q,q+n); for(int i=0;i<n;i++){ while(top>=2 && area(q[stk[top-2]],q[stk[top-1]],q[i])<=0){ if(area(q[stk[top-2]],q[stk[top-1]],q[i])<0){ used[stk[--top]]=false; } else top--; } stk[top++]=i; used[i]=true; } used[0]=false; for(int i=n-1;i>=0;i--){ if(used[i]) continue; while(top>=2 && area(q[stk[top-2]],q[stk[top-1]],q[i])<=0){ top--; } stk[top++]=i; } top--; } int rotating_calipers(){ if(top<=2) return get_dist(q[0],q[n-1]); int res=0; for(int i=0,j=2;i<top;i++){ auto d=q[stk[i]],e=q[stk[i+1]]; while(area(d,e,q[stk[j]])<area(d,e,q[stk[j+1]])) j=(j+1)%top; res=max(res,max(get_dist(d,q[stk[j]]),get_dist(e,q[stk[j]]))); } return res; } int main(){ cin>>n; for(int i=0;i<n;i++){ cin>>q[i].x>>q[i].y; } get_convex(); printf(\"%d\\n\",rotating_calipers()); return 0; }","title":"\u65cb\u8f6c\u5361\u58f3"},{"location":"algorithms/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF/xzkk/#_1","text":"#include<bits/stdc++.h> using namespace std; #define x first #define y second typedef pair<int,int> PII; const int N=50010; int n; PII q[N]; int stk[N],top; bool used[N]; PII operator- (PII a,PII b){ return {a.x-b.x,a.y-b.y}; } int operator* (PII a,PII b){ return a.x*b.y-a.y*b.x; } int area(PII a,PII b,PII c){ return (b-a)*(c-a); } int get_dist(PII a,PII b){ int dx=a.x-b.x; int dy=a.y-b.y; return dx*dx+dy*dy; } void get_convex(){ sort(q,q+n); for(int i=0;i<n;i++){ while(top>=2 && area(q[stk[top-2]],q[stk[top-1]],q[i])<=0){ if(area(q[stk[top-2]],q[stk[top-1]],q[i])<0){ used[stk[--top]]=false; } else top--; } stk[top++]=i; used[i]=true; } used[0]=false; for(int i=n-1;i>=0;i--){ if(used[i]) continue; while(top>=2 && area(q[stk[top-2]],q[stk[top-1]],q[i])<=0){ top--; } stk[top++]=i; } top--; } int rotating_calipers(){ if(top<=2) return get_dist(q[0],q[n-1]); int res=0; for(int i=0,j=2;i<top;i++){ auto d=q[stk[i]],e=q[stk[i+1]]; while(area(d,e,q[stk[j]])<area(d,e,q[stk[j+1]])) j=(j+1)%top; res=max(res,max(get_dist(d,q[stk[j]]),get_dist(e,q[stk[j]]))); } return res; } int main(){ cin>>n; for(int i=0;i<n;i++){ cin>>q[i].x>>q[i].y; } get_convex(); printf(\"%d\\n\",rotating_calipers()); return 0; }","title":"\u65cb\u8f6c\u5361\u58f3"},{"location":"linux/caozuo/","text":"linux \u5e38\u7528\u6307\u4ee4 ls \u5217\u51fa\u6587\u4ef6\u5939\u7684\u5185\u5bb9 \u53c2\u6570 -d \u663e\u793a\u6587\u4ef6\u5939\u672c\u8eab\u5c5e\u6027 -F \u663e\u793a\u6587\u4ef6\u7c7b\u578b\uff0c\u5e76\u6dfb\u52a0\u4e0d\u540c\u6807\u5fd7","title":"linux \u5e38\u7528\u6307\u4ee4"},{"location":"linux/caozuo/#linux","text":"ls \u5217\u51fa\u6587\u4ef6\u5939\u7684\u5185\u5bb9 \u53c2\u6570 -d \u663e\u793a\u6587\u4ef6\u5939\u672c\u8eab\u5c5e\u6027 -F \u663e\u793a\u6587\u4ef6\u7c7b\u578b\uff0c\u5e76\u6dfb\u52a0\u4e0d\u540c\u6807\u5fd7","title":"linux \u5e38\u7528\u6307\u4ee4"}]}